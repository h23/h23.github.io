{"meta":{"title":"前端学习笔记","subtitle":null,"description":null,"author":"h23","url":"https://h23.github.io/hexo"},"pages":[{"title":"All categories","date":"2018-06-27T08:11:48.000Z","updated":"2019-03-15T06:57:05.867Z","comments":true,"path":"categories/index.html","permalink":"https://h23.github.io/hexo/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-06-27T08:09:57.000Z","updated":"2019-03-15T06:57:05.875Z","comments":true,"path":"tags/index.html","permalink":"https://h23.github.io/hexo/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP基础","slug":"HTTP基础","date":"2019-03-13T14:21:34.000Z","updated":"2019-03-15T07:22:10.604Z","comments":true,"path":"2019/03/13/HTTP基础/","link":"","permalink":"https://h23.github.io/hexo/2019/03/13/HTTP基础/","excerpt":"","text":"HTTP基础HTTP是用于传输诸如HTML的超媒体文档的应用层协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用。 1. web请求过程 用户在浏览器的地址栏中输入URL 浏览器解析域名和端口 将域名解析成IP地址 先查看本地缓存中是否有对应条目 无则向DNS服务器发送请求 通过随机端口与服务器建立连接，根据IP&amp;端口号确定服务器 发送请求报文 服务端接收到请求后，根据URL找到目标文件 根据MIME TYPE判断目标文件的类型 浏览器通过MIME Type区分不同的媒体资源 HTTP中MIME Type类型被定义在Content-Type中 Content-Type: [type]/[subtype] 静态文件则包装成响应报文原路返回给浏览器 动态文件则将执行后的文件包装成响应报文原路返回给浏览器 浏览器接收到响应报文后，根据content-type确认类型，然后处理响应数据 如果是HTML则渲染到界面上 2. HTTP请求2.1 报文格式 2.2 常见请求方法 GET &amp; POST Get Post 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 | 编码类型 | application/x-www-form-urlencoded | application/x-www-form-urlencoded或 multipart/form-data。为二进制数据使用多重编码 || 历史 | 参数保留在浏览器历史中 | 参数不会保存在浏览器历史中 || 数据长度 | 当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 | 无限制 || 数据类型限制 | 只允许 ASCII 字符 | 没有限制。也允许二进制数据 || 安全性 | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 || 可见性 | 数据在 URL 中对所有人都是可见的。 | 数据不会显示在 URL 中。 | 总的来说，GET用于获取某个内容，POST用于提交某种数据请求，从使用场景来看，一般用户注册的内容是私密的，应该使用POST方式来保持私密，而当需要查询某个内容时，需要快速响应，则使用GET。 2.2.1 GET用来请求访问已经被URL识别的资源。指定的资源经过服务端解析后返回响应的内容。简单来说，就是请求的资源是文本的话，那么就保持原样返回。 2.2.2 POST用来传输实体的主体。 3. HTTP响应3.1 报文格式 3.2 常见状态码状态码通常就是服务器端对客户端说的话，分类如下： 状态码 含义 1** 服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重新定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 常见的状态码： 200 通常的成功 OK 12GET：请求的对应资源会作为响应返回。响应将包含描述或操作的结果。 POST：返回处理对应请求的结果。 204 成功处理请求，没有返回任何内容 No Content 1表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应。比如，客户端是浏览器的话，那么浏览器显示的页面不会发生更新。 206 Partial Content 1成功处理了部分GET请求 301 Moved Permanently 1请求的网页已永久移动到新位置，永久性重定向 302 Found 1网站临时性重定向，暂时不能访问（备案、被查） 303 See Other 1该状态码表示由于请求对应的资源存在另一个URI，并指定必须使用GET方法定向获取请求的资源。和302不同的是，302是不会改变上次的请求方法 304 Not Modified 1访问不了，并返回和上次一样的话,表示资源未被修改过，还是和上次访问时一样。 307 Temporary Redirect 1临时重定向，和302、303类似，不同的是，不会指定客户端要用什么样的方法请求. 400 Bad Request 1表示客户端中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。 401 Unauthorized 1即用户没有必要的凭据。该状态码表示当前请求需要用户验证。 403 Forbidden 1服务器已经理解请求，但是拒绝执行它。 404 Not Found 1服务器找不到请求的网页。 500 Internal Server Error 1服务器遇到错误，无法完成请求。 503 Service Unavailable 1由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的. 4. Chrome请求截图 最常属性： URL, 即http访问的地址 request method, 报文的请求方式 status code, 状态码以及状态短语 Accept Encoding, 内容编码 由于有些报文的内容会过大，为了减少传输时间，HTTP会采取一些压缩的措施，例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式gzip。 总的来说内容编码的格式有以下几种： gzip:GNU压缩格式 compress:UNIX系统的标准压缩格式 deflate:是一种同时使用了LZ77和哈夫曼编码的无损失压缩格式 identity:不进行压缩 Connection, 连接方式 正常发送HTTP时，我们需要建立TCP的连接，然后再发送报文： 如果每次都要发送HTTP报文都需要经历上面的拿过过程，无疑将会耗费很多时间在建立和断开连接的过程中，因此HTTP使用了connection属性，用于指定连接的方式，当当设置成keep-alive时，就会建立一条持久化的连接。这样就不需要每次都建立连接在中断连接： （HTTP1.1中connection默认开启keep-alive） Cookie, 添加的cookie内容 由于HTTP是一种无状态的协议，这是由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息，从而减轻服务器端的负载，同时无状态也减小了HTTP请求的开销。 但当有些场景需要时刻记住用户的信息时，无状态很明显不能满足需求，因此HTTP提供了cookie来解决这个问题，cookie技术通过在请求和相应报文中写入cookie信息来控制客户端的状态。cookie会根据从服务端发送的相应报文内的一个叫做set-cookie的首部字段信息，通知客户端保存cookie。当下次客户端再往服务器发送请求的时候，客户端会自动在请求头加入cookie值后发送出去。在没有cookie状态下的请求： 当存有cookie后的请求： 简单来说Cookie是一种由服务器端确定，并保存在客户端浏览器中的内容。这样就与每次都去添加用户的信息，请求会自动添加cookie中对应的内容。 Host, 目标主机 User-Agent, 客户端浏览器的相关信息 Set-Cookie, 指定想要在Cookie中保存的内容","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://h23.github.io/hexo/tags/HTTP/"}],"keywords":[]},{"title":"浏览器兼容性学习1","slug":"浏览器兼容性学习1","date":"2019-01-11T06:24:46.000Z","updated":"2019-03-15T06:57:05.861Z","comments":true,"path":"2019/01/11/浏览器兼容性学习1/","link":"","permalink":"https://h23.github.io/hexo/2019/01/11/浏览器兼容性学习1/","excerpt":"","text":"概述产生兼容性问题的原因：浏览器（不同内核，内核版本，浏览器品牌）不同，同样的代码在不一样的浏览器上运行就存在兼容性问题。因为不同浏览器使用内核及所支持的HTML等网页语言标准不同；以及用户客户端的环境不同（如分辨率不同）造成的显示效果不能达到理想效果。 兼容性主要考虑三方面： CSS兼容 JavaScript兼容 HTML兼容 1. 浏览器内核 Trident ：Microsoft公司浏览器内核，IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）及许多品牌浏览器的内核。其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“极速浏览模式”，而Trident（IE内核）则是”兼容浏览模式”。 edge：微软专门为新IE打造的引擎，目前IE11使用该内核，估计以后微软的新浏览器会继续采用该内核。 Webkit：Safari内核，Chrome内核原型，开源，它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 傲游浏览器3、Apple Safari、(Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。 Blink：Blink是一个由Google和Opera Software开发的浏览器排版引擎，Chrome（28及往后版本）、Opera（15及往后版本）。 Presto：Opera前内核，已废弃，Opera现已改用Google Chrome的Blink内核。 2. CSS兼容2.1 CSS Reset每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。 这样会有很多兼容性问题： 可通过CSS Reset（http://cssreset.com/）将所有浏览器默认样式设置成一样。 Normalize （http://nicolasgallagher.com/about-normalize-css/）号称是CSS reset的替代方案，保留了一些内置的样式，并不是清除所有。 2.2 CSS HackCSS Hack针对IE浏览器写的特定的CSS样式达到让浏览器兼容。 少用 2.2.1 条件注释法IE私有代码，在其他浏览器中被视为注释。 gt : greater than，&gt; lt : less than， &lt; gte : greater than or equal，&gt;= lte : less than or equal， &lt;= ! : 非 12345678910&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt;用于 IE9 &lt;![endif]--&gt;&lt;!--[if gt IE 6]&gt; 用于 IE6 以上版本&lt;![endif]--&gt;&lt;!--[if lte IE 7]&gt; 用于 IE7或更低版本 &lt;![endif]--&gt;&lt;!--[if gte IE 8]&gt;用于 IE8 或更高版本 &lt;![endif]--&gt;&lt;!--[if lt IE 9]&gt;用于 IE9 以下版本&lt;![endif]--&gt;&lt;!--[if !IE 8]&gt; --&gt;用于非 IE &lt;!-- &lt;![endif]--&gt; 2.2.2 样式内属性标记法 “\\9″ IE6/IE7/IE8/IE9/IE10都生效 “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack ！important 除IE6都支持 2.3 文档模式（X-UA-Compatible）文档模式是IE8后的独有技术，通过meta指定当前文档的渲染模式。文档模式控制浏览器显示网页HTML的方式，用于指定IE的页面排版引擎（Trident）以哪个版本的方式来解析并渲染网页代码。 x-ua-compatible 头标签大小写不敏感，必须用在 head 中，必须在除 title 外的其他 meta 之前使用。 123456&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=6\" &gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\" &gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" &gt;最新IE&lt;meta http-equiv=\"x-ua-compatible\" content=\"IE=7,9,10\" &gt;&lt;meta http-equiv =\"X-UA-Compatible\" content = \"IE=edge,chrome=1\" /&gt;Google Chrome Frame(谷歌内嵌浏览器框架GCF),插件可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核 2.4 respond.js解决 ie9 以下浏览器不支持 CSS3 Media Query 的问题。 1&lt;script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt; 2.5 浏览器前缀1234-o- : Opera-ms- : IE-moz- : Firefox-webkit- : Chrome 2.6 常见问题处理2.6.1 清除浮动1234.fl &#123; float: left; &#125;.fr &#123; float: right; &#125;.clearfix:after &#123; display: block; clear: both; content: \"\"; visibility: hidden; height: 0; &#125;.clearfix &#123; zoom: 1; &#125; 2.6.2 IE9一下浏览器不能用opacity (未成功)123opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 2.6.3 让IE 7 8 支持CSS3 background-size(未测试)由于 background-size 是 CSS3 新增的属性，所以 IE 低版本自然就不支持了，但是老外写了一个 htc 文件，名叫 background-size polyfill，使用该文件能够让 IE7、IE8 支持 background-size 属性。其原理是创建一个 img 元素插入到容器中，并重新计算宽度、高度、left、top 等值，模拟 background-size 的效果。 12345678910111213html &#123; height: 100%;&#125;body &#123; height: 100%; margin: 0; padding: 0; background-image: url('img/37.png'); background-repeat: no-repeat; background-size: cover; -ms-behavior: url('css/backgroundsize.min.htc'); behavior: url('css/backgroundsize.min.htc');&#125; 2.6.4 td 自动换行的问题问题：table 宽度固定，td 自动换行 解决：设置 Table 为 table-layout: fixed，td 为 word-wrap: break-word 2.7 IE兼容性IE浏览器自从IE9开始后，做了很大的改动，更符合了W3C标准，这也是为啥IE8比其他问题要更多的原因了。其中IE11已更完善，像IE11中就内置了IE7-IE10的浏览器模式（按F12打开开发者工具可见），方便开发进行更低版本的调试。 3. JS兼容JS兼容包括两个方面： 通过JS控制样式与标签，强制浏览器兼容 JS存在兼容问题 3.1 键盘事件 keyCode 兼容性写法1234567891011var inp = document.getElementById('inp')var result = document.getElementById('result')function getKeyCode(e) &#123; e = e ? e : (window.event ? window.event : \"\") return e.keyCode ? e.keyCode : e.which&#125;inp.onkeypress = function(e) &#123; result.innerHTML = getKeyCode(e)&#125; 3.2 求窗口大小的兼容写法1234567891011121314151617// 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）// 1600 * 525var client_w = document.documentElement.clientWidth || document.body.clientWidth;var client_h = document.documentElement.clientHeight || document.body.clientHeight;// 网页内容实际宽高（包括工具栏和滚动条等边线）// 1600 * 8var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth;var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight;// 网页内容实际宽高 (不包括工具栏和滚动条等边线）// 1600 * 8var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth;var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight;// 滚动的高度var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop; 3.3 DOM 事件处理程序的兼容写法（能力检测）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var eventshiv = &#123; // event兼容 getEvent: function(event) &#123; return event ? event : window.event; &#125;, // type兼容 getType: function(event) &#123; return event.type; &#125;, // target兼容 getTarget: function(event) &#123; return event.target ? event.target : event.srcelem; &#125;, // 添加事件句柄 addHandler: function(elem, type, listener) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, listener, false); &#125; else if (elem.attachEvent) &#123; elem.attachEvent('on' + type, listener); &#125; else &#123; // 在这里由于.与'on'字符串不能链接，只能用 [] elem['on' + type] = listener; &#125; &#125;, // 移除事件句柄 removeHandler: function(elem, type, listener) &#123; if (elem.removeEventListener) &#123; elem.removeEventListener(type, listener, false); &#125; else if (elem.detachEvent) &#123; elem.detachEvent('on' + type, listener); &#125; else &#123; elem['on' + type] = null; &#125; &#125;, // 添加事件代理 addAgent: function (elem, type, agent, listener) &#123; elem.addEventListener(type, function (e) &#123; if (e.target.matches(agent)) &#123; listener.call(e.target, e); // this 指向 e.target &#125; &#125;); &#125;, // 取消默认行为 preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 阻止事件冒泡 stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 4. HTML兼容4.1 html5shiv.js解决 ie9 以下浏览器对 html5 新增标签不识别的问题。 123&lt;!--[if lt IE 9]&gt; &lt;script type=\"text/javascript\" src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 4.2 picturefill.js解决 IE 9 10 11 等浏览器不支持 &lt;picture&gt; 标签的问题 1&lt;script src=\"https://cdn.bootcss.com/picturefill/3.0.3/picturefill.min.js\"&gt;&lt;/script&gt; 5.兼容性测试工具Browser Sandbox http://caniuse.com/","categories":[],"tags":[{"name":"浏览器兼容性","slug":"浏览器兼容性","permalink":"https://h23.github.io/hexo/tags/浏览器兼容性/"}],"keywords":[]},{"title":"dva2","slug":"dva2","date":"2018-12-14T04:40:37.000Z","updated":"2019-03-15T06:57:05.835Z","comments":true,"path":"2018/12/14/dva2/","link":"","permalink":"https://h23.github.io/hexo/2018/12/14/dva2/","excerpt":"","text":"1. 核心概念 State：object，保存整个应用状态，即储存数据的地方。收到 Action 以后，会更新数据。 View：React 组件构成的视图层。从 State 取数据后，渲染成 HTML 代码。只要 State 有变化，View 就会自动更新。 Action：object，描述 UI 层事件。 connect 方法：function，绑定 State 到 View。 123456import &#123; connect &#125; from 'dva';function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;connect(mapStateToProps)(App); // 第一个参数是 mapStateToProps 函数，mapStateToProps 函数会返回一个对象，用于建立 State 到 Props 的映射关系。 dispatch 方法：function，发送 Action 到 State。 12345dispatch(&#123; type: 'click-submit-button', payload: this.form.data&#125;)// 被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。 2. dva 应用的最简结构2.1 不带Model123456789import dva from 'dva';const App = () =&gt; &lt;div&gt;Hello dva&lt;/div&gt;;// 创建应用const app = dva();// 注册视图app.router(() =&gt; &lt;App /&gt;);// 启动应用app.start('#root'); 2.2 带Model1234567891011121314151617181920212223// 创建应用const app = dva();// 注册 Modelapp.model(&#123; // 所有的应用逻辑都定义 app.model 对象上 namespace: 'count', state: 0, reducers: &#123; add(state) &#123; return state + 1 &#125;, &#125;, effects: &#123; *addAfter1Second(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'add' &#125;); &#125;, &#125;,&#125;);// 注册视图app.router(() =&gt; &lt;ConnectedApp /&gt;);// 启动应用app.start('#root'); 3. Model 对象的属性 namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成 state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出 reducers: Action 处理器，处理同步动作，用来算出最新的 State effects：Action 处理器，处理异步动作 3.1 ReducerReducer 是 Action 处理器，用来处理同步操作，可以看做是 state 的计算器。它的作用是根据 Action，从上一个 State 算出当前 State。 1234567891011121314// count +1function add(state) &#123; return state + 1; &#125;// 往 [] 里添加一个新 todofunction addTodo(state, action) &#123; return [...state, action.payload]; &#125;// 往 &#123; todos: [], loading: true &#125; 里添加一个新 todo，并标记 loading 为 falsefunction addTodo(state, action) &#123; return &#123; ...state, todos: state.todos.concat(action.payload), loading: false &#125;;&#125; 3.2 Effect 基于 Redux-saga 实现。 Effect 指的是副作用。根据函数式编程，计算以外的操作都属于 Effect，典型的就是 I/O 操作、数据库读写。 Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。 dva 提供多个 effect 函数内部的处理函数，比较常用的是 call 和 put。 call：执行异步函数 put：发出一个 Action，类似于 dispatch 1234function *addAfter1Second(action, &#123; put, call &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: 'add' &#125;);&#125;","categories":[],"tags":[{"name":"dva","slug":"dva","permalink":"https://h23.github.io/hexo/tags/dva/"}],"keywords":[]},{"title":"dva1","slug":"dva1","date":"2018-12-07T04:29:46.000Z","updated":"2019-03-15T06:57:05.830Z","comments":true,"path":"2018/12/07/dva1/","link":"","permalink":"https://h23.github.io/hexo/2018/12/07/dva1/","excerpt":"","text":"1. 基础概念dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装。dva 是 framework。 dva最核心的是提供了 app.model 方法，用于把 reducer, initialState, action, saga 封装到一起： 1234567891011121314151617181920212223242526272829app.model(&#123; namespace: 'products', state: &#123; list: [], loading: false, &#125;, subscriptions: [ function(dispatch) &#123; dispatch(&#123;type: 'products/query'&#125;); &#125;, ], effects: &#123; ['products/query']: function*() &#123; yield call(delay(800)); yield put(&#123; type: 'products/query/success', payload: ['ant-tool', 'roof'], &#125;); &#125;, &#125;, reducers: &#123; ['products/query'](state) &#123; return &#123; ...state, loading: true, &#125;; &#125;, ['products/query/success'](state, &#123; payload &#125;) &#123; return &#123; ...state, loading: false, list: payload &#125;; &#125;, &#125;,&#125;); 在有 dva 之前，我们通常会创建 sagas/products.js, reducers/products.js 和 actions/products.js，然后在这些文件之间来回切换。 介绍下这些 model 的 key ： namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值 state - 对应 reducer 的 initialState subscription - elm@0.17 的新概念，在 dom ready 后执行 effects - 对应 saga，并简化了使用 reducers 2. 数据流向数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过 dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State ，如果是异步行为会先触发 Effects 然后流向 Reducers 最终改变 State。 3. Models3.1 State1type State = any State 表示 Model 的状态数据，操作的时候每次都要当作不可变数据来对待，保证每次都是全新对象，没有引用关系，这样才能保证 State 的独立性，便于测试和追踪变化。 可通过 dva 的实例属性 _store 看到顶部的 state 数据，少用: 12const app = dva();console.log(app._store); // 顶部的 state 数据 3.2 Action1type AsyncAction = any Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。 123dispatch(&#123; type: 'add',&#125;); 3.3 dispatch 函数1type dispatch = (a: Action) =&gt; Action dispatching function 是一个用于触发 action 的函数，action 是改变 State 的唯一途径，但是它只描述了一个行为，而 dipatch 可以看作是触发这个行为的方式，而 Reducer 则是描述如何改变数据的。 在 dva 中，connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects，例： 1234dispatch(&#123; type: 'user/add', // 如果在 model 外调用，需要添加 namespace payload: &#123;&#125;, // 需要传递的信息&#125;); 3.4 Reducer1type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。 3.5 SubscriptionSubscriptions 是一种从 源 获取数据的方法。 Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。 12345678910import key from 'keymaster';...app.model(&#123; namespace: 'count', subscriptions: &#123; keyEvent(&#123;dispatch&#125;) &#123; key('⌘+up, ctrl+up', () =&gt; &#123; dispatch(&#123;type:'add'&#125;) &#125;); &#125;, &#125;&#125;); 4. Router前端路由: 由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API可以监听浏览器url的变化，从而控制路由相关操作。 dva 实例提供了 router 方法来控制路由，使用的是react-router。 123456import &#123; Router, Route &#125; from 'dva/router';app.router((&#123;history&#125;) =&gt; &lt;Router history=&#123;history&#125;&gt; &lt;Route path=\"/\" component=&#123;HomePage&#125; /&gt; &lt;/Router&gt;);","categories":[],"tags":[{"name":"dva","slug":"dva","permalink":"https://h23.github.io/hexo/tags/dva/"}],"keywords":[]},{"title":"Redux高级","slug":"Redux高级","date":"2018-11-23T00:54:24.000Z","updated":"2019-03-15T06:57:05.809Z","comments":true,"path":"2018/11/23/Redux高级/","link":"","permalink":"https://h23.github.io/hexo/2018/11/23/Redux高级/","excerpt":"","text":"1. 异步Action当调用异步 API 时，有两个非常关键的时刻：发起请求的时刻，和接收到响应的时刻（也可能是超时）。这两个时刻都可能会更改应用的 state；为此，你需要 dispatch 普通的同步 action。一般情况下，每个 API 请求都需要 dispatch 至少三种 action： 一种通知 reducer 请求开始的 action。 对于这种 action，reducer 可能会切换一下 state 中的 isFetching 标记。以此来告诉 UI 来显示加载界面。 一种通知 reducer 请求成功的 action。 对于这种 action，reducer 可能会把接收到的新数据合并到 state 中，并重置 isFetching。UI 则会隐藏加载界面，并显示接收到的数据。 一种通知 reducer 请求失败的 action。 对于这种 action，reducer 可能会重置 isFetching。另外，有些 reducer 会保存这些失败信息，并在 UI 里显示出来。 将同步action创建函数与网络请求结合：要引入 redux-thunk 这个专门的库才能使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import fetch from 'cross-fetch'export const REQUEST_POSTS = 'REQUEST_POSTS'function requestPosts(subreddit) &#123; return &#123; type: REQUEST_POSTS, subreddit &#125;&#125;export const RECEIVE_POSTS = 'RECEIVE_POSTS'function receivePosts(subreddit, json) &#123; return &#123; type: RECEIVE_POSTS, subreddit, posts: json.data.children.map(child =&gt; child.data), receivedAt: Date.now() &#125;&#125; export const INVALIDATE_SUBREDDIT = ‘INVALIDATE_SUBREDDIT’ export function invalidateSubreddit(subreddit) &#123; return &#123; type: INVALIDATE_SUBREDDIT, subreddit &#125; &#125;// 来看一下我们写的第一个 thunk action 创建函数！// 虽然内部操作不同，你可以像其它 action 创建函数 一样使用它：// store.dispatch(fetchPosts('reactjs'))function fetchPosts(subreddit) &#123; // Thunk middleware 知道如何处理函数。 // 这里把 dispatch 方法通过参数的形式传给函数， // 以此来让它自己也能 dispatch action。 return function (dispatch) &#123; // 首次 dispatch：更新应用的 state 来通知 API 请求发起了。 dispatch(requestPosts(subreddit)) // thunk middleware 调用的函数可以有返回值，它会被当作 dispatch 方法的返回值传递。 // 这个案例中，我们返回一个等待处理的 promise。这并不是 redux middleware 所必须的，但这对于我们而言很方便。 return fetch(`http://www.subreddit.com/r/$&#123;subreddit&#125;.json`) .then( response =&gt; response.json(), // 不要使用 catch，因为会捕获在 dispatch 和渲染中出现的任何错误，导致 'Unexpected batch number' 错误。https://github.com/facebook/react/issues/6895 error =&gt; console.log('An error occurred.', error) ) .then(json =&gt; // 可以多次 dispatch！这里，使用 API 请求结果来更新应用的 state。 dispatch(receivePosts(subreddit, json)) ) &#125; function shouldFetchPosts(state, subreddit) &#123; const posts = state.postsBySubreddit[subreddit] if (!posts) &#123; return true &#125; else if (posts.isFetching) &#123; return false &#125; else &#123; return posts.didInvalidate &#125;&#125;export function fetchPostsIfNeeded(subreddit) &#123; // 注意这个函数也接收了 getState() 方法 // 它让你选择接下来 dispatch 什么。 // 当缓存的值是可用时， // 减少网络请求很有用。 return (dispatch, getState) =&gt; &#123; if (shouldFetchPosts(getState(), subreddit)) &#123; // 在 thunk 里 dispatch 另一个 thunk！ return dispatch(fetchPosts(subreddit)) &#125; else &#123; // 告诉调用代码不需要再等待。 return Promise.resolve() &#125; &#125;&#125;&#125; 2. MiddlewareRedux middleware 被用于提供位于 action 被发起之后，到达 reducer 之前的扩展点。 你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * 记录所有被发起的 action 以及产生的新的 state。 */const logger = store =&gt; next =&gt; action =&gt; &#123; console.group(action.type) console.info('dispatching', action) let result = next(action) console.log('next state', store.getState()) console.groupEnd(action.type) return result&#125;/** * 在 state 更新完成和 listener 被通知之后发送崩溃报告。 */const crashReporter = store =&gt; next =&gt; action =&gt; &#123; try &#123; return next(action) &#125; catch (err) &#123; console.error('Caught an exception!', err) Raven.captureException(err, &#123; extra: &#123; action, state: store.getState() &#125; &#125;) throw err &#125;&#125;/** * 用 &#123; meta: &#123; delay: N &#125; &#125; 来让 action 延迟 N 毫秒。 * 在这个案例中，让 `dispatch` 返回一个取消 timeout 的函数。 */const timeoutScheduler = store =&gt; next =&gt; action =&gt; &#123; if (!action.meta || !action.meta.delay) &#123; return next(action) &#125; const timeoutId = setTimeout(() =&gt; next(action), action.meta.delay) return function cancel() &#123; clearTimeout(timeoutId) &#125;&#125;/** * 通过 &#123; meta: &#123; raf: true &#125; &#125; 让 action 在一个 rAF 循环帧中被发起。 * 在这个案例中，让 `dispatch` 返回一个从队列中移除该 action 的函数。 */const rafScheduler = store =&gt; next =&gt; &#123; const queuedActions = [] let frame = null function loop() &#123; frame = null try &#123; if (queuedActions.length) &#123; next(queuedActions.shift()) &#125; &#125; finally &#123; maybeRaf() &#125; &#125; function maybeRaf() &#123; if (queuedActions.length &amp;&amp; !frame) &#123; frame = requestAnimationFrame(loop) &#125; &#125; return action =&gt; &#123; if (!action.meta || !action.meta.raf) &#123; return next(action) &#125; queuedActions.push(action) maybeRaf() return function cancel() &#123; queuedActions = queuedActions.filter(a =&gt; a !== action) &#125; &#125;&#125;/** * 使你除了 action 之外还可以发起 promise。 * 如果这个 promise 被 resolved，他的结果将被作为 action 发起。 * 这个 promise 会被 `dispatch` 返回，因此调用者可以处理 rejection。 */const vanillaPromise = store =&gt; next =&gt; action =&gt; &#123; if (typeof action.then !== 'function') &#123; return next(action) &#125; return Promise.resolve(action).then(store.dispatch)&#125;/** * 让你可以发起带有一个 &#123; promise &#125; 属性的特殊 action。 * * 这个 middleware 会在开始时发起一个 action，并在这个 `promise` resolve 时发起另一个成功（或失败）的 action。 * * 为了方便起见，`dispatch` 会返回这个 promise 让调用者可以等待。 */const readyStatePromise = store =&gt; next =&gt; action =&gt; &#123; if (!action.promise) &#123; return next(action) &#125; function makeAction(ready, data) &#123; const newAction = Object.assign(&#123;&#125;, action, &#123; ready &#125;, data) delete newAction.promise return newAction &#125; next(makeAction(false)) return action.promise.then( result =&gt; next(makeAction(true, &#123; result &#125;)), error =&gt; next(makeAction(true, &#123; error &#125;)) )&#125;/** * 让你可以发起一个函数来替代 action。 * 这个函数接收 `dispatch` 和 `getState` 作为参数。 * * 对于（根据 `getState()` 的情况）提前退出，或者异步控制流（ `dispatch()` 一些其他东西）来说，这非常有用。 * * `dispatch` 会返回被发起函数的返回值。 */const thunk = store =&gt; next =&gt; action =&gt; typeof action === 'function' ? action(store.dispatch, store.getState) : next(action)// 你可以使用以上全部的 middleware！（当然，这不意味着你必须全都使用。）const todoApp = combineReducers(reducers)const store = createStore( todoApp, applyMiddleware( rafScheduler, timeoutScheduler, thunk, vanillaPromise, readyStatePromise, logger, crashReporter )) 3. 搭配React-Router &lt;Provider /&gt; 是由 React Redux 提供的高阶组件，用来让你将 Redux 绑定到 React 。 1234567const Root = (&#123; store &#125;) =&gt; ( &lt;Provider store=&#123;store&#125;&gt; &lt;Router&gt; &lt;Route path=\"/\" component=&#123;App&#125; /&gt; &lt;/Router&gt; &lt;/Provider&gt;) Link: 1234567891011121314import React from 'react'import &#123; NavLink &#125; from 'react-router-dom'const FilterLink = (&#123; filter, children &#125;) =&gt; ( &lt;NavLink to=&#123;filter === 'SHOW_ALL' ? '/' : `/$&#123;filter&#125;`&#125; activeStyle=&#123;&#123; textDecoration: 'none', color: 'black' &#125;&#125; &gt; &#123;children&#125; &lt;/NavLink&gt;)export default FilterLink； 从URL中读取数据： 123456789101112131415const App = (&#123; match: &#123; params &#125; &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList filter=&#123;params.filter || 'SHOW_ALL'&#125; /&gt; &lt;Footer /&gt; &lt;/div&gt; )&#125;const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, ownProps.filter) // 以前是 getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://h23.github.io/hexo/tags/Redux/"}],"keywords":[]},{"title":"Redux-动手实现redux","slug":"Redux-动手实现redux","date":"2018-11-16T06:43:43.000Z","updated":"2019-03-15T06:57:05.792Z","comments":true,"path":"2018/11/16/Redux-动手实现redux/","link":"","permalink":"https://h23.github.io/hexo/2018/11/16/Redux-动手实现redux/","excerpt":"","text":"1. 传统props数据传递的弊端react数据相关属性： state：用来维护组件内部产生数据的信息 props：用来维护组件外部传入数据的信息 context：用来维护跨级组件信息的传递 当前数据传递过于麻烦，通过props一级一级的向下传递，同级组件之间的数据传递还需要提升状态。而context将数据放到全局，任意组件都可直接读/写全局的数据。 2. 使用context来提供全局参数context属性的使用步骤： 准备阶段 在产生参数的最顶级组件中，使用childContextTypes静态属性来定义需要放入全局参数的类型 123static childContextTypes=&#123; title: PropTypes.string&#125; 在父组件中，提供状态，来管理数据 123state = &#123; title : 'xxx'&#125; 声明子组件获取全局参数的方式 12345getChildContext()&#123; return &#123; title : this.state.title &#125;&#125; 使用 在子组件中，使用contextTypes静态属性，声明需要获取父组件放入全局context中的参数类型 123static contextTypes=&#123; title:PropTypes.string&#125; 在子组件需要的地方获取全局参数： this.context.全局属性名 1this.context.title 3. 自己动手编写redux-准备Redux：全局的状态管理。 模拟Redux步骤： 声明一个全局状态 123let appState=&#123; title:'xx&#125; 定义一个全局渲染方法 12345678910const renderApp=(state)=&gt;&#123; renderScreen(state.title)&#125;const renderScren=(title)=&gt;&#123;// 1)获取页面元素 const screenEl = document.querySelector('screen');// 2)对页面元素进行修改 screenEl.innerHTML = title;&#125; 全局初始化 1renderApp(appState) 提供修改状态方法：对按钮进行监听，修改状态 123document.querySelector('button').addEventListener('click',()=&gt;&#123; appState.tite='hahaha'&#125;) 重新渲染 1renderApp(appState) 当前问题： 模块（组件）间需要共享的数据是直接暴露在全局的 全局的状态依旧可以直接修改，会导致不可预料的结果 4. 通过createStore函数管理状态 定义一个createStore的函数，来管理全局状态数据 12345678910111213141516171819202122const createStore = ()=&gt;&#123; // 1) 初始化数据 let state=&#123; title: 'xx' &#125; // 2) 给外部提供获取数据的方法 const getState = ()=&gt; state; // 3) 提供一个dispatch方法，修改数据 const dispath = action=&gt;&#123; // 3.1) 对操作类型进行判断 switch (action.type)&#123; case 'Update': state.title=action.text; break; case 'Undo': break; default: &#125; &#125; // 4) 暴露获取数据&amp;修改数据的方法 return &#123; getStore , dispatch &#125;&#125; 使用createStore函数来创建数据的管理对象 1const store=createStore() 定义一个全局渲染方法 12345678910const renderApp=(state)=&gt;&#123; renderScreen(state.title)&#125;const renderScren=(title)=&gt;&#123;// 1)获取页面元素 const screenEl = document.querySelector('screen');// 2)对页面元素进行修改 screenEl.innerHTML = title;&#125; 全局初始化 1renderApp(store.getState()) 修改状态 123document.querySelector('button').addEventListener('click',()=&gt;&#123; store.dispath(&#123;type:'Update'&#125;)&#125;) 重新渲染 1renderApp(store.getState()) 当前问题： 在createStore组件中，dispatch函数的操作代码写死在了内部，这样不利于扩展. 解决：把dispatch函数的执行方法抽离出去，在创建store时，动态传入。 5. 使用纯函数来管理状态 对状态的修改，交给纯函数 12345678910let changeState = (state, action)=&gt;&#123; switch (action.type)&#123; case 'Update': state.title=action.text; break; case 'Undo': break; default: &#125;&#125; 定义一个createStore的函数，来管理全局状态数据，传入状态修改函数 123456789101112const createStore = ( changeState )=&gt;&#123; // 1) 初始化数据 let state=&#123; title: 'xx' &#125; // 2) 给外部提供获取数据的方法 const getState = ()=&gt; state; // 3) 提供一个dispatch方法，修改数据 const dispath = action =&gt; changeState(state,action) // 4) 暴露获取数据&amp;修改数据的方法 return &#123; getStore , dispatch &#125;&#125; 全局渲染方法 使用createStore函数来创建数据的管理对象 1const store=createStore( changeState ) 全局初始化 修改状态 重新渲染 当前问题： 每次修改状态后还需手动渲染页面，能不能自动化？ 解决：把状态修改后的操作，交给订阅方法，把需要做的渲染操作添加到订阅中，会在状态修改后自动完成渲染操作。 6. 使用订阅函数来解放双手 对状态的修改，交给纯函数 定义一个createStore的函数，来管理全局状态数据，传入状态修改函数 1234567891011121314151617181920212223242526const createStore = ( changeState )=&gt;&#123; // 1) 初始化数据 let state=&#123; title: 'xx' &#125; // 4.1) 声明监听数组 let listeners = []; // 2) 给外部提供获取数据的方法 const getState = ()=&gt; state; // 3) 提供一个dispatch方法，修改数据 const dispath = action =&gt; &#123; // 3.1) 修改数据 // 5）将返回的新state，赋值给state state=changeState(state,action); // 3.2) 调用所有监听 listeners.forEach(listener=&gt;listener()); &#125; // 4) 监听&amp;订阅 // 4.2) 提供一个‘订阅’方法，对特定状态修改进行相应 const subscribe=listener=&gt;&#123; listeners.push(listener) &#125; // 5) 暴露获取数据&amp;修改数据的方法 return &#123; getStore, dispatch, subscribe &#125;&#125; 全局渲染方法 使用createStore函数来创建数据的管理对象 当状态发生改变时，执行重新渲染函数 1234store.subscribe(()=&gt;&#123; // 重新渲染函数调用 renderApp(store.getState())&#125;) 全局初始化 修改状态 当前问题： 每次修改会触发批量更新，有一部分是无用功，严重的性能问题。 解决：修改判断标准，能够识别状态内容的变化，调用对应的方法。在每次渲染前，对渲染的内容做一次判断，区分新老状态的差别，对渲染进行细粒度控制。 7. 完成渲染优化 对状态的修改，交给纯函数 12345678910111213let changeState = (state, action)=&gt;&#123; switch (action.type)&#123; case 'Update': // 返回一个新状态，与旧state无关 return &#123; ...state, title: action.text &#125; case 'Undo': break; default: &#125;&#125; 定义一个createStore的函数，来管理全局状态数据，传入状态修改函数 1234567891011121314151617const createStore = ( changeState )=&gt;&#123; let state=&#123; title: 'xx' &#125; let listeners = []; const getState = ()=&gt; state; const dispath = action =&gt; &#123; // 将返回的新state，赋值给state state=changeState(state,action); listeners.forEach(listener=&gt;listener()); &#125; const subscribe=listener=&gt;&#123; listeners.push(listener) &#125; return &#123; getStore, dispatch, subscribe &#125;&#125; 全局渲染方法 123456789101112const renderApp=(newState,oldState=&#123;&#125;)=&gt;&#123; // 如果新老状态一致，则不需要重新渲染。 if(newState===oldState) return; renderScreen(newState.title,oldState.title)&#125;const renderScren=(newTitle,oldTitle)=&gt;&#123; // 如果新老title一致，则不需要重新渲染 if(newTitle====oldTitle) return; const screenEl = document.querySelector('screen'); screenEl.innerHTML = title;&#125; 使用createStore函数来创建数据的管理对象 存储旧状态 1let oldState=store.getState(); 当状态发生改变时，执行重新渲染函数 12345678store.subscribe(()=&gt;&#123; // 获取新状态 const newState=store.getState(); // 重新渲染函数调用,传入新老状态 renderApp(newState,oldState) // 新状态用过之后就变成了老状态 oldState=newState;&#125;) 全局初始化 修改状态","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://h23.github.io/hexo/tags/Redux/"}],"keywords":[]},{"title":"Redux基础","slug":"Redux基础2","date":"2018-11-02T06:45:08.000Z","updated":"2019-03-15T06:57:05.803Z","comments":true,"path":"2018/11/02/Redux基础2/","link":"","permalink":"https://h23.github.io/hexo/2018/11/02/Redux基础2/","excerpt":"","text":"1. ActionAction：将数据从应用传到store的有效载荷。是store数据的唯一来源。通过store.dispatch()将action传到store。 action示例： action是一个JS对象，必须包含type属性。 1234567&#123; type: ADD_TODO, // type通常是字符串常量 text: 'Build my first Redux app'&#125;注：若应用规模较大，建议使用单独的模块或文件来存放actionimport &#123; ADD_TODO, REMOVE_TODO &#125; from '../actionTypes' 尽量减少在action中传递的数据。 Action创建函数：返回action的函数。 2. ReducerReducers： 指定了应用状态的变化如何响应 actions并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。 Reducer 是一个纯函数，接收旧state和action，返回新state。(oldState,action)=&gt;newState。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。 不要再Reducer中做一下操作： 修改传入参数 执行有副作用的操作，如API请求和路由跳转 调用非纯函数，如Date.now() or Math.random() 1234567891011121314151617import &#123; VisibilityFilters &#125; from './actions' // actionconst initialState = &#123; // 初始state visibilityFilter: VisibilityFilters.SHOW_ALL, todos: []&#125;;function todoApp(state = initialState, action) &#123; // reducer switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; // 返回new state，通过Object.assign创建（第一个参数必须为空对象。因为不能修改state，而Object.assign对改变第一个参数的值。） visibilityFilter: action.filter &#125;) default: // 默认情况下返回旧state return state &#125;&#125; 推荐做法： 开发一个函数来做为主 reducer 主 reducer调用多个子 reducer 分别处理 state 中的一部分数据 主 reducer把这些数据合成一个大的单一对象 主 reducer 并不需要设置初始化时完整的 state。初始时，如果传入 undefined, 子 reducer 将负责返回它们的默认值。 注意每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据。 Reducer合成： combineReducers() 12345678import &#123; combineReducers &#125; from 'redux'const todoApp = combineReducers(&#123; visibilityFilter, todos&#125;)export default todoApp 3. Storeaction： 用于描述发生了什么。reducer： 用于根据action更新state。 Store 就是把它们联系到一起的对象。Store 有以下职责： 维持应用的 state； 提供 getState()方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener)返回的函数注销监听器。 通过createStore(主reducer，state 初始状态)创建store，Redux 应用只有一个单一的 store。","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://h23.github.io/hexo/tags/Redux/"}],"keywords":[]},{"title":"Redux基础1","slug":"Redux基础1","date":"2018-10-26T07:38:38.000Z","updated":"2019-03-15T06:57:05.795Z","comments":true,"path":"2018/10/26/Redux基础1/","link":"","permalink":"https://h23.github.io/hexo/2018/10/26/Redux基础1/","excerpt":"","text":"简介Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。 Redux 除了和 React一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。 要点：应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。 12345678910store = state集合通过createStore（reducer）创建storeAPI： subscribe, dispatch, getStatereducer = （state，action）=&gt; new state 的纯函数，决定每个action如何改变state。一个应用只能有一个根reducer，可有多个子reducer。action描述如何改变state的对象，可以清晰地知道应用中到底发生了什么。store.dispatch(action) 改变state的唯一方法。 三大原则 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 state是只读的 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers。","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://h23.github.io/hexo/tags/Redux/"}],"keywords":[]},{"title":"JS拖拽","slug":"JS拖拽","date":"2018-10-11T15:03:18.000Z","updated":"2019-03-15T06:57:05.736Z","comments":true,"path":"2018/10/11/JS拖拽/","link":"","permalink":"https://h23.github.io/hexo/2018/10/11/JS拖拽/","excerpt":"","text":"1. 基础1234567891011121314151617181920212223242526272829var oImg = document.getElementById('img1');drag(oImg);function drag(obj) &#123; // 拖拽函数 obj.onmousedown = function(ev) &#123; var ev = ev || event; // 元素被点击时，获取鼠标位置和当前元素位置的差 var disX = ev.clientX - this.offsetLeft; var disY = ev.clientY - this.offsetTop; if ( obj.setCapture ) &#123; //非标准IE，取消文字、图片默认拖拽效果 obj.setCapture(); &#125; // 将鼠标移动事件添加到document上，防止鼠标移动太快，离开元素导致元素不会跟随鼠标移动 document.onmousemove = function(ev) &#123; var ev = ev || event; //点击过程中，移动鼠标时，使元素跟随鼠标移动 obj.style.left = ev.clientX - disX + 'px'; obj.style.top = ev.clientY - disY + 'px'; &#125; // 将鼠标释放事件添加到document上，防止鼠标在上层元素上释放导致元素会一直跟随鼠标移动 document.onmouseup = function() &#123; // 释放鼠标时，取消move事件，不跟随鼠标移动 document.onmousemove = document.onmouseup = null; if ( obj.releaseCapture ) &#123; // 非标准IE，取消文字、图片默认拖拽效果 obj.releaseCapture(); &#125; &#125; return false;// 标准浏览器，取消文字、图片默认拖拽效果 &#125;&#125; 2. 在可视区内拖拽12345678910111213141516171819document.onmousemove = function(ev) &#123; var ev = ev || event; var L = ev.clientX - disX; var T = ev.clientY - disY; if ( L &lt; 0 ) &#123; // 当移动到可视区的最左边时，固定显示在0的位置。 L = 0; &#125;else if ( L &gt; document.documentElement.clientWidth - obj.offsetWidth ) &#123; // 当移动到可视区的最右边时，固定显示在最右位置。 L = document.documentElement.clientWidth - obj.offsetWidth; &#125; if ( T &lt; 0 ) &#123; // 同上 T = 0; &#125; else if ( T &gt; document.documentElement.clientHeight - obj.offsetHeight ) &#123; T = document.documentElement.clientHeight - obj.offsetHeight; &#125; obj.style.left = L + 'px';// 其他位置可自由移动 obj.style.top = T + 'px';&#125; 3. 拖拽吸附原理：在移动到某一个范围内，设置成想要的值。 123456789101112131415161718document.onmousemove = function(ev) &#123; var ev = ev || event; var L = ev.clientX - disX; var T = ev.clientY - disY; if ( L &lt; 100 ) &#123;// 在可视区内拖拽的效果上仅修改了这个值 L = 0; &#125; else if ( L &gt; document.documentElement.clientWidth - obj.offsetWidth ) &#123; L = document.documentElement.clientWidth - obj.offsetWidth; &#125; if ( T &lt; 0 ) &#123; T = 0; &#125; else if ( T &gt; document.documentElement.clientHeight - obj.offsetHeight ) &#123; T = document.documentElement.clientHeight - obj.offsetHeight; &#125; obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125; 4. 碰撞检测 12345678910111213141516171819202122232425document.onmousemove = function(ev) &#123; var ev = ev || event; var L = ev.clientX - disX; var T = ev.clientY - disY; // 获取拖拽元素各边的位置值 var L1 = L; var R1 = L + obj.offsetWidth; var T1 = T; var B1 = T + obj.offsetHeight; // 获取另一元素各边的位置值 var L2 = oImg.offsetLeft; var R2 = L2 + oImg.offsetWidth; var T2 = oImg.offsetTop; var B2 = T2 + oImg.offsetHeight; // 在九宫格中间位置以外的区域都不会发生碰撞 if ( R1 &lt; L2 || L1 &gt; R2 || B1 &lt; T2 || T1 &gt; B2 ) &#123; oImg.src = '1.jpg'; &#125; else &#123; oImg.src = '2.jpg'; &#125; obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125; 5. 拖拽resize 123456789101112131415161718192021222324252627282930var oDiv = document.getElementById('div1');oDiv.onmousedown = function(ev) &#123; var ev = ev || event; var disW = this.offsetWidth; // 获取点击时元素的宽度 var disL = this.offsetLeft; // 获取点击时元素的X轴位置 var disX = ev.clientX; // 获取点击时鼠标的X轴位置 var b = ''; if ( mouseX &gt; divL + divW - 10 ) &#123; b = 'right'; &#125; if ( mouseX &lt; divL + 10 ) &#123; b = 'left'; &#125; document.onmousemove = function(ev) &#123; var ev = ev || event; switch( b ) &#123; case 'left': // 点击左边区域时，修改宽度和左边位置 oDiv.style.width = divW - ( ev.clientX - mouseX ) + 'px'; oDiv.style.left = divL + ( ev.clientX - mouseX ) + 'px'; break; case 'right':// 点击右边区域时，修改宽度 oDiv.style.width = divW + ( ev.clientX - mouseX ) + 'px'; break; &#125; &#125; document.onmouseup = function() &#123; document.onmousemove = document.onmouseup = null; &#125; return false;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Typora使用","slug":"Typora使用","date":"2018-09-30T06:10:26.000Z","updated":"2019-03-15T06:57:05.814Z","comments":true,"path":"2018/09/30/Typora使用/","link":"","permalink":"https://h23.github.io/hexo/2018/09/30/Typora使用/","excerpt":"","text":"基本介绍Typora是一款所见即所得的Markdown文本编辑工具——在你输入相应的标记符号后，系统会自动对所标记的文本进行渲染，设置成相应的格式。因此，写作过程与渲染过程同步出现，最终输出文本就是按照你所看到的格式进行排版。 本文不会介绍markdown语法，仅介绍一些个人觉得好用的功能。 代码块语法高亮操作：选中代码块，在代码块右下角的select a language框中输入语言类型。 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div&gt;Hello world!&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 关键词高亮开启高亮：文件-&gt;偏好设置-&gt;Markdown语法扩展-&gt;勾选高亮。 使用：在==中插入需要关键词来实现，如: ==关键词== 。 输入emoji表情😄 :smile: 只需要输入：和第一个字母即可出现候选的emoji表情。如:smile。 绘制图表流程图例子： 1234567​```mermaidgraph LRA[矩形框] --&gt;B(圆角框) B --&gt; C&#123;菱形框&#125; C --&gt;|情况1| D[结果1] C --&gt;|情况2| E[结果2]​ 1234567```mermaidgraph LRA[矩形框] --&gt;B(圆角框) B --&gt; C&#123;菱形框&#125; C --&gt;|情况1| D[结果1] C --&gt;|情况2| E[结果2] Typora自带了http://flowchart.js.org/插件，所以支持流程图。hexo博客显示不出来，后面在处理。 常用快捷键1. 字体相关加粗：Ctrl+B 斜体：Ctrl+I 标题：Ctrl+数字 下划线：Ctrl+U 删除线：alt+shift+5 2. 操作相关选中一整行：ctrl+l 选中单词：ctrl+d 返回开头：Ctrl+Home 返回结尾：Ctrl+End 替换：ctrl+h 显示/隐藏侧边栏： ctrl+shift+L 或左下角的第一个按钮 显示/关闭源码模式：ctrl+/ 或左下角的第二个按钮 3. 其他生成表格：Ctrl+T 创建链接：Ctrl+K 生成目录：[TOC]按回车 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl+k","categories":[],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://h23.github.io/hexo/tags/Typora/"}],"keywords":[]},{"title":"Git","slug":"Git","date":"2018-09-20T08:29:31.000Z","updated":"2019-03-15T06:57:05.724Z","comments":true,"path":"2018/09/20/Git/","link":"","permalink":"https://h23.github.io/hexo/2018/09/20/Git/","excerpt":"","text":"1. 基础概念Git： 分散型版本管理系统，是为版本管理而设计的软件。 版本管理: 管理更新的历史记录。能够记录软件添加或更改源代码的过程，回滚到特定阶段，恢复误删除的文件等。 简单说就是用于管理多人协同开发项目的技术。 SVN与Git： 原理上 Git直接记录文件快照，SVN每次记录哪些文件作了更新、更新哪些行的内容 Git 有本地仓库和远程仓库，SVN没有本地仓库 Git 大多数操作是本地执行，SVN操作几乎都需要连接网络 操作上 Git提交后保存在本地仓库，需要推到远程仓库；SVN提交后在远程仓库 Git有各种“反悔”命令，SVN几乎没有 Git有真正的branch，svn的branch其实是工作空间的副 Git工作区：工作目录、暂存区、资源库 、远程的git仓库 。 2. Git配置 git config -l ： 查看现在的git环境详细配置 查看系统config： git config –system –list 查看当前用户（global）配置： git config –global –list 查看当前仓库配置信息： git config –local –list Git在$HOME目录中查找.gitconfig文件（一般位于C:\\Documents and Settings\\$USER下） ： /etc/gitconfig：包含了适用于系统所有用户和所有项目的值。 ~/.gitconfig：只适用于当前登录用户的配置。 位于git项目目录中的.git/config：适用于特定git项目的配置。 2.1 设置用户名与邮箱每次Git提交都会使用到用户名和邮箱信息。 12git config --global user.name \"xx\" git config --global user.email xx@xx.com 2.2 添加/删除配置项123git config [--local|--global|--system] section.key valuegit config [--local|--global|--system] --unset section.key [–local|–global|–system] 可选的 –local 项目级 –global 当前用户级 –system 系统级 section.key 区域下的键 value 对应的值 2.3 其他配置项1234567891011121314151617181920212223git config --global color.ui true #打开所有的默认终端着色git config --global alias.ci commit #别名 ci 是commit的别名[alias] co = checkout ci = commit st = status pl = pull ps = push dt = difftool l = log --stat cp = cherry-pick ca = commit -a b = branch user.name #用户名user.email #邮箱core.editor #文本编辑器 merge.tool #差异分析工具 core.paper \"less -N\" #配置显示方式 color.diff true #diff颜色配置 alias.co checkout #设置别名git config user.name #获得用户名git config core.filemode false #忽略修改权限的文件 3. Git操作3.1. 新建仓库1git init [project-name] 3.2. Clone仓库1git clone [url] 3.3. 文件操作GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。 3.3.1 查看文件状态文件的状态： Untracked: 未跟踪, 文件加入到git库, 不参与版本控制. 通过git add状态变为Staged. Unmodify: 文件已经入库, 未修改 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 通过git add进入暂存staged状态 使用git checkout 则丢弃修改过, 返回到unmodify状态 Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 12345#查看指定文件状态git status [filename]#查看所有文件状态git status 3.3.2 添加文件与目录工作区&gt;暂存区： 12345678添加指定文件到暂存区git add [file1] [file2] ...添加指定目录到暂存区，包括子目录git add [dir]添加当前目录的所有文件到暂存区git add . 撤销add: 12345直接从暂存区删除文件，工作区则不做出改变git rm --cached &lt;file&gt;如果已经用add命令把文件加入stage了，就先需要从stage中撤销git reset HEAD &lt;file&gt;... 移除文件： 1234567891011移除所有未跟踪文件：一般会加上参数-df，-d表示包含目录，-f表示强制清除。git clean [options] 只从stage中删除，保留物理文件git rm --cached readme.txt 不但从stage中删除，同时删除物理文件git rm readme.txt 把a.txt改名为b.txtgit mv a.txt b.txt 3.3.3 文件修改后差异对比12345678查看文件修改后的差异git diff [files]比较暂存区的文件与之前已经提交过的文件git diff --cached比较repo与工作空间中的文件差异git diff HEAD~n","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://h23.github.io/hexo/tags/Git/"}],"keywords":[]},{"title":"React-router1","slug":"React-router1","date":"2018-09-14T01:06:28.000Z","updated":"2019-03-15T06:57:05.778Z","comments":true,"path":"2018/09/14/React-router1/","link":"","permalink":"https://h23.github.io/hexo/2018/09/14/React-router1/","excerpt":"","text":"1.基本概念React Router包含3个包： react-router：提供所有核心组件，函数，整个路由 react-router-dom：运行在浏览器环境 react-router-native：运行RN环境 react-router-dom有3种基础组件： router components &lt;BrowserRouter&gt; ：响应请求的服务器 url：http://example.com/about 使用HTML5的history API记录路由历史 &lt;HashRouter&gt; ：静态文件的服务器 url：http://example.com/#/about 使用URL(window.location.hash)的hash部分来记录 兼容老式浏览器 Web 服务并不会解析 hash，也就是说 # 后的内容 Web 服务都会自动忽略，但是 JavaScript 是可以通过 window.location.hash 读取到的，读取到路径加以解析之后就可以响应不同路径的逻辑处理。 Router组件会创建一个 history 对象，history 用来跟踪 URL, 当URL 发生变化时， Router的后代组件会重新渲染。 Router组件只能有一个子元素。 route matching components &lt;Route&gt;：通过path 属性和当前地址的 pathname实现路由匹配。 路由渲染属性： component render：需要传值时才使用。 children &lt;Switch&gt; ：非必需。 &lt;Switch&gt; 会遍历其所有的子 &lt;Route&gt; 元素，并仅渲染与当前地址匹配的第一个元素。 navigation components &lt;Link&gt; ：会被转换成&lt;a&gt; &lt;NavLink&gt; : 特殊类型的 &lt;Link&gt; ，有活跃状态（to 属性与当前地址匹配时）。 &lt;Redirect&gt;：强制导航。当一个 &lt;Redirect&gt; 渲染时，它将使用它的 to 属性进行定向。 2. 简单示例2.1 基本路由1234567891011121314151617181920212223242526272829// 1.安装下载react-router-dom//app.jsimport React, &#123; Component &#125; from 'react';import &#123; Link, Route, Switch &#125; from 'react-router-dom'; //2.引入相关router组件const Home = () =&gt; (&lt;div&gt;&lt;h2&gt;Home&lt;/h2&gt;&lt;/div&gt;)const Category = () =&gt; (&lt;div&gt;&lt;h2&gt;Category&lt;/h2&gt;&lt;/div&gt;)const Products = () =&gt; (&lt;div&gt;&lt;h2&gt;Products&lt;/h2&gt;&lt;/div&gt;)class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;nav className=\"navbar navbar-light\"&gt; &lt;ul className=\"nav navbar-nav\"&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Homes&lt;/Link&gt;&lt;/li&gt; //3.将当前路径导航到‘/’ &lt;li&gt;&lt;Link to=\"/category\"&gt;Category&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/products\"&gt;Products&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" component=&#123;Home&#125;/&gt; //4.当当前路径=path值时，显示Home组件 &lt;Route path=\"/category\" component=&#123;Category&#125;/&gt; &lt;Route path=\"/products\" component=&#123;Products&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 2.2 嵌套路由123456789101112131415161718192021//1.在2.1的基础上，去掉app.js中的Category组件。//2.新增Category.jsimport React from 'react';import &#123; Link, Route &#125; from 'react-router-dom';const Category = (&#123; match &#125;) =&gt; &#123; //传入math对象return( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/shoes`&#125;&gt;Shoes&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/boots`&#125;&gt;Boots&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/footwear`&#125;&gt;Footwear&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;match.path&#125;/:name`&#125; //‘/:name’变量，匹配两个/之间的字符串 render= &#123;(&#123;match&#125;) =&gt;(&lt;h3&gt; &#123;match.params.name&#125; &lt;/h3&gt;)&#125; //通过match.params.name获得path中'/:name'变量匹配的字符串 /&gt; &lt;/div&gt; )&#125;export default Category; 3. 组件详解3.1 &lt;BrowserRouter&gt; &amp; &lt;HashRouter&gt;&lt;BrowserRouter&gt;使用HTML的history API保持UI和URL的同步。 &lt;HashRouter&gt;使用 URL 的 hash 部分（即 window.location.hash ）保持UI和URL的同步。 基本写法： 123&lt;BrowserRouter&gt; &lt;App /&gt;&lt;/BrowserRouter&gt; 基本属性说明： basename: string - 所有地址的基本网址。 basename=&quot;/calendar&quot; 结尾不能有斜线 3.2 &lt;Route&gt;Route组件的作用：当前路径 与 path属性匹配时渲染相应组件。不匹配则渲染为空。 基本写法： 12&lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt;&lt;Route component=&#123;NotFound&#125; /&gt; //当路径不匹配path时显示NotFound组件，要放最后。404页面 基本属性说明： path： 用于标识路由匹配的URL的pathname/hash部分。 当前路径===路由路径时，会生成一个match对象作为 props 中的一个 属性传递给被渲染的组件。包含关于URL和path的信息。 match.url：返回URL匹配部分的字符串。用来构建嵌套链接 match.path：返回路由路径字符串。用来构建嵌套路由 match.isExact：返回布尔值，当 URL 完全匹时，值为 true; 当 URL 部分匹配时，值为 false. match.params：Route的 path 可以包含参数，例如 &lt;Route path=”/foo/:id” 包含一个参数 id。params就是用于从匹配的 URL 中解析出 path 中的参数，例如，当 URL = ‘http://example.ocm/foo/1&#39; 时，params= {id: 1}。 exact: 精确匹配路径。默认会显示所有匹配路径的组件。 渲染方法： component: string 只有当位置匹配时才会渲染的 React 组件。 渲染时会使用React.createElement创建新的react元素。每次都会创建一个新组件，而不是更新现有组件。 render：func 返回一个React元素。 不会创建新react元素。 方便地为待渲染组件传递额外的属性。 children: func返回一个React元素。 不管路径是否匹配，children都会渲染。 不匹配时，match=null 3.3 &lt;Switch&gt;用于包裹Route组件，只有第一个匹配路径的子Route组件会被渲染。 3.4 &lt;Link&gt;提供声明式的，可访问的导航。 基本写法： 1&lt;Link to=\"/about\"&gt;About&lt;/Link&gt; 基本属性说明： to: String - 链接到的地址 replace: bool - 单击链接将替换历史堆栈中的当前入口，而不是添加新入口。 3.5 &lt;NavLink&gt;特殊版本的&lt;Link&gt;，有active状态，并可设置active状态的样式。active状态：路径与route.path匹配时。 基本写法： 1&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt; 基本属性说明： activeClassName: string - 指定active时的样式类 activeStyle: object - 设置active时的样式。 exact: bool - 仅在路径完全匹配时才应用active的类or样式。 3.6 &lt;Redirect&gt;用于导航到一个新的地址。新地址会覆盖history 栈中的当前地址，类似服务器端（HTTP 3xx）的重定向。 基本写法： 1&lt;Redirect to=\"/dashboard\"/&gt; 基本属性说明： to: String - 重定向到的地址 push: bool - 将新地址推入 history 中，而不是替换当前地址。 3.7 Historyhistory对象用来记录当前路径（history.location）。 history对象的属性和方法： 属性： length location：当前位置。 pathname -URL 路径 search -URL 中的查询字符串 hash -URL 的哈希片段 state - 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。 方法： push( path,[state] ) replace( path,[state] ) go( n ) goBack() goForward() block( prompt ) 阻止跳转 3.8 locationrouter在以下几处提供了location 对象： Route component as this.props.location Route render as ({ location }) =&gt; () Route children as ({ location }) =&gt; () withRouter as this.props.location 3.9 match当路由路径和当前路径成功匹配，会生成match对象。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示： match.url.返回URL匹配部分的字符串。对于创建嵌套的很有用。 match.path.返回路由路径字符串 – 就是。将用来创建嵌套的。 match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。 match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。 一个 match 对象中包涵了有关如何匹配 URL 的信息。 router在以下几处提供了 match 对象： Route component 例如 this.props.match Route render 例如 ({ match }) =&gt; () Route children 例如 ({ match }) =&gt; () withRouter 例如 this.props.match matchPath 例如 返回值 3.10 &lt;Prompt&gt;页面跳转前提示框，用户点击确定后才跳转。 属性： when: boolean值，true显示提示框 message：func，提示返回值 123456&lt;Prompt when=&#123;isBlocking&#125; message=&#123;location =&gt; `Are you sure you want to go to $&#123;location.pathname&#125;` &#125;/&gt; 其他后端路由多页应用中，一个URL对应一个HTML页面，一个Web应用包含很多HTML页面，在多页应用中，页面路由控制由服务器端负责，这种路由方式称为后端路由。 多页应用中,每次页面切换都需要向服务器发送一次请求，页面使用到的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致共用部分的刷新。 在单面应用中，URL发生并不会向服务器发送新的请求，所以“逻辑页面”的路由只能由前端负责，这种路由方式称为前端路由。 前端的路由和后端的路由在实现技术上不一样，但是原理都是一样的。 从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。","categories":[],"tags":[{"name":"React-router","slug":"React-router","permalink":"https://h23.github.io/hexo/tags/React-router/"}],"keywords":[]},{"title":"React","slug":"React","date":"2018-08-17T08:08:46.000Z","updated":"2019-03-15T06:57:05.787Z","comments":true,"path":"2018/08/17/React/","link":"","permalink":"https://h23.github.io/hexo/2018/08/17/React/","excerpt":"","text":"1. 简介React用于构建用户界面的JS库。 特点： 声明式：为应用的每个状态设计视图，在数据改变时更新渲染界面。 组件化 一次学习，随处编写 2. 安装创建react项目：单页面 12345npm install -g create-react-app //安装环境create-react-app my-app //创建应用 应用名称my-app 最好使用正确的路径cd my-app npm start //开始使用 添加react到已有项目 12npm initnpm install --save react react-dom 3. JSX简介JSX用来声明React中的元素，是React.createElement()的语法糖。 必须声明React变量import React from &#39;react&#39;; 推荐在JSX代码的外面包上小括号，防止自动插入分号的bug。 书写JSX时会带上换行和缩进，增强代码可读性。 单标签需在结尾加上/。 JSX标签可相互嵌套。 基本语法规则：遇到HTML标签就用HTML规则解析，遇到代码块（{）就用JS规则解析。 大写开头的JSX标签表示自定义react组件。会被编译成同名变量并引用。 其余则是内置组件，如div, span。HTML原生标签。 3.1 在JSX中使用表达式JSX中可包含任意JS表达式，注意表达式要包含在大括号中。 JSX本身也是一种表达式，可在if,for中使用，将它复制给变量，当作参数传入，作为返回值。 JS表达式： 原始表达式 this 标识符引用 字面量引用（若是数组则展开数组的所有成员） 分组表达式 （） 复杂表达式 属性访问表达式 对象创建表达式 函数表达式 原始表达式+操作符 123456789101112131415161718192021function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root'));页面显示：Hello, Harper Perez! 3.2 JSX属性两种方式： 引号包括的字符串值属性 大括号包裹的JS表达式值属性 12const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt;;const element = &lt;img src=&#123;user.avatarUrl&#125;/&gt;; 注意： 属性值默认为true，建议写全。 123以下两种是等价的：&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 属性可扩展...props。 属性名要用驼峰式命名。 特殊属性名：class-&gt;className. 3.4 子代在JSX开始和结束标签中的内容作为特殊的参数（props.children）传递。 类型： 字符串常量 JSX 会移除空行和开始与结尾处的空格 字符串常量内部的换行会被压缩成一个空格 JSX JS表达式 {} 函数 3.3 JSX代表ObjectsBabel 转译器会把 JSX 转换成一个名为 React.createElement()的方法调用。 下面两种代码的作用是完全相同的： 1234567891011const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement()创建出来的对象被称为react元素。是屏幕上看到的东西。react通过读取这些对象来构建DOM并保持数据内容一致。 4. 元素渲染元素是构成React应用的最小单位。元素是构成组件的一个部分。 React元素 != 浏览器DOM元素，React DOM确保两种元素的数据内容一致。 4.1 将元素渲染到DOM中 在HTML页面中添加一个根DOM节点。 1&lt;div id=\"root\"&gt;&lt;/div&gt; //此div中的所有内容都将由 React DOM 来管理 将react元素渲染到根DOM节点中。 12345const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; //react元素ReactDOM.render( //通过ReactDOM.render(react元素,根DOM节点)方法实现渲染 element, document.getElementById('root') //根DOM节点); 4.2 更新元素渲染React元素是不可变的，一个元素代表应用界面在某一时间点的样子。 目前更新界面的方式：创建一个新的元素，然后传入ReactDOM.render方法。 注意：在实际生产开发中，大多数React应用只会调用一次 ReactDOM.render()。 React DOM只会更新渲染文本节点中发生变化的内容。React DOM首先会比较元素内容先后的不同，在渲染过程中只更新改变的部分。 基于React进行开发时所有的DOM构造都是通过虚拟DOM进行。每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别。然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并。 5. 组件&amp;Props组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。 组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。 5.1 定义组件 组件名首字母必须大写。 组件的返回值只能有一个根元素。 定义方式： 函数定义组件 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 类定义组件 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 5.2 组件渲染React元素：DOM标签，自定义组件。 React渲染组件时，会将JSX属性作为单个对象传递给该组件，这个对象称之为props。 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"Sara\" /&gt;; //将&#123;name=\"Sara\"&#125;传递给WelcomeReactDOM.render( element, document.getElementById('root')); 5.3 组合组件组件可以在输出中引用其他组件。 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 5.4 Props的只读性纯函数不修改输入值。所有的React组件必须像纯函数那样使用它们的props。 5.5 检查组件属性PropTypes包含一整套验证器，可用于确保你接收的数据是有效的。出于性能原因，propTypes只在开发模式下进行检查。 12345678910111213import PropTypes from 'prop-types'; //引入PropTypesclass Greeting extends React.Component &#123; //创建自定义组件 render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; //检查自定义组件的属性 name: PropTypes.string&#125;; 限制单个子代 1234567891011121314151617import PropTypes from 'prop-types';class MyComponent extends React.Component &#123; render() &#123; // This must be exactly one element or it will warn. const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired //只传递一个子代&#125;; 定义props默认值 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 为属性指定默认值:Greeting.defaultProps = &#123; name: 'Stranger'&#125;;// 渲染 \"Hello, Stranger\":ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example')); 5.6 静态类型检查大型项目建议用Flow和typeScript这样的静态类型检查器来代替propstype。在代码运行之前识别某些类型的问题。 5.6.1 FlowFlow是一个针对 JavaScript 代码的静态类型检查器。 它可以让你使用特殊的类型语法来注释变量，函数和React组件，并尽早地发现错误。 使用步骤： 将 Flow 添加到您的项目作为依赖项。 12345678910yarn:yarn add --dev flow-bin //安装最新版的 Flowyarn run flow init //创建一个您需要提交的 Flow 配置文件npm:npm install --save-dev flow-binnpm run flow init在package.json的scripts中：\"flow\": \"flow\", 确保编译后的代码中去除了 Flow 语法。 12345678for babel:yarn: yarn add --dev babel-preset-flownpm: npm install --save-dev babel-preset-flow在.babelrc的presets中:[\"flow\"]注：Create React App已自动去除了Flow语法 添加了类型注释并运行 Flow 来检查它们。 123456运行flow：yarn flownpm run flow添加flow类型注释：1.在待检查的文件顶部添加： //@flow 5.6.2 TypeScriptTypeScript 是一门由微软开发的编程语言。 它是 JavaScript 的一个类型超集，包含它自己的编译器。 作为一种类型化语言，Typescript 可以早在您的应用程序上线之前在构建时发现错误和错误。 使用步骤： 将 Typescript 添加为您的项目的依赖项 12345yarn: yarn add --dev typescriptnpm: npm install --save-dev typescript在package.json的scripts中：\"build\": \"tsc\", 配置 TypeScript 编译器选项 12运行tsc --init生成tsconfig.json，在此文件中配置规则。。。。 使用正确的文件扩展名 12.ts 默认的文件扩展名.tsx 包含JSX的文件扩展名 为你使用的库添加定义 123yarn buildnpm run build如果你没有看到输出，这意味着它完全编译成功了。 6. State&amp;生命周期在类组件中，react使用state对象来存放组件的数据，state里的数据变化时，这个组件就会被重新渲染。 react中的数据流是单向的，自顶向下的。 有state属性的组件被称为有状态组件。 组件的数据存储在prop和state中： props state 传入组件的参数，即外部传入组件内部的数据。父组件向子组件传递数据。 组件自己管理的数据 只读 可变，通过this.setState()修改。 只能通过外部组件传入新props来重新渲染子组件。 this.setState()修改state后，react会重新调用render(),重新渲染组件 6.1 将函数转换为类步骤： 创建一个类，继承React.Component 创建一个render() 将函数体移动到render()中 在render()中，使用this.props替换props 删除剩余的空函数声明 6.2 为一个类添加局部状态 在render()中，将this.props.xx替换为this.state.xx。 为类组件添加一个constructor构造器，并在构造器中初始化state。只能在构造器中初始化this.state 通过 this.setState({}/function, function) 修改state。 第一个参数：对象或函数，只需传入需要更新的数据，不需要传入整个对象 第二个参数：函数，在setState调用完并且组件开始重新渲染时调用，可用来监听渲染是否完成。 123456789101112131415class Cl extends React.Component &#123; constructor(props) &#123; super(props); //调用父类的构造函数 this.state = &#123;date: new Date()&#125;; //初始化state，在第一次render时，使用这个数据来渲染组件。 &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toString()&#125;.&lt;/h2&gt; //调用state &lt;/div&gt; ); &#125;&#125; 6.3 将生命周期方法添加到类中在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。 我们可以在组件类上声明特殊的方法，当组件挂载或卸载时，来运行一些代码 。这些方法被称作生命周期钩子。 12componentDidMount() &#123;&#125; //挂载：当组件输出到DOM后执行，建立定时器componentWillUnmount() &#123;&#125; //卸载：销毁组件时执行，关闭定时器 方法调用顺序： 当组件被传递给ReactDOM.render() 时，react调用组件的构造函数。初始化this.state. 调用组件的render()，更新DOM一匹配组件的渲染输出。 当组件的输出插入到DOM时，react调用componentDidMount() 生命周期钩子。 在此方法中通过this.setState()更新state。 更新state后，react知道状态已改变会重新调用render()重新渲染。 当组件被移除出DOM时，react会调用componentWillUnmount()这个钩子函数。 7. 事件处理React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同。 1234567&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;&lt;button onClick=&#123;activateLasers&#125;&gt; //1.React事件绑定属性的命名采用驼峰式写法，而不是小写 Activate Lasers //2.如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)&lt;/button&gt; 不能通过return false阻止默认行为。必须明确使用event.preventDefault()。 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); //绑定事件处理函数中的this &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 7.1 向事件处理程序传递参数两种方式： 123456781.通过箭头函数&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;2.通过bind()&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;bind()注意：*隐式传递event。*事件处理函数中event要排在所传递参数的最后面。deleteRow(id,e) 注意：通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面。 8. 条件渲染React 中的条件渲染使用 JavaScript 操作符 if 或 条件运算符 来创建表示当前状态的元素，然后让 React 根据它们来更新UI。 12345if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125; 8.1 与运算符&amp;&amp;在JS中true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。 12345678910111213141516171819202122function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; //当unreadMessages.length&gt;0成立时，渲染&lt;h2&gt; &#125; &lt;/div&gt; );&#125;const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById('root'));//Hello!//You have 3 unread messages. 8.2 三目运算符12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 8.3 阻止组件渲染通过render()返回null，实现组件隐藏。 组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。 9. 列表&amp;keys9.1 基础列表组件123456789101112131415function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 9.2 KeysKeys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。 元素的key只有在它和它的兄弟节点对比时才有意义。所以key只需在兄弟之间是唯一的，不需要是全局唯一的。 123456789101112131.使用数据的id作为元素的keyconst todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;);2.若无id，则使用数组索引作为key。如果列表可重新排序，不建议使用索引作为keyconst todoItems = todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 123456789101112131415161718192021function ListItem(props) &#123; return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;; // 这里不需要指定key:&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; //key应该在数组的上下文中被指定 ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 当你在map()的内部调用元素时，你最好随时记得为每一个元素加上一个独一无二的key。 10. 表单10.1 受控组件受控组件通常react会构造一个处理提交表单并可访问用户输入表单数据的函数。 值由react控制的输入表单元素称为受控组件。 10.1.1 &lt;input&gt;123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 10.1.2&lt;textarea&gt;React中\\&lt;textarea>会用value属性来代替文本内容。则\\&lt;textarea>\\&lt;input>方式相同。 10.1.3 &lt;select&gt;React中在\\&lt;select>上用value属性来标识选中项。 1234567891011121314151617181920212223242526272829303132333435class FlavorForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: 'coconut'&#125;; //初始选中项 this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('Your favorite flavor is: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Pick your favorite La Croix flavor: &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; //通过value属性标识选中项 &lt;option value=\"grapefruit\"&gt;Grapefruit&lt;/option&gt; &lt;option value=\"lime\"&gt;Lime&lt;/option&gt; &lt;option value=\"coconut\"&gt;Coconut&lt;/option&gt; &lt;option value=\"mango\"&gt;Mango&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 10.1.4 多输入123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value //ES6,计算属性名 &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=\"isGoing\" type=\"checkbox\" checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=\"numberOfGuests\" type=\"number\" value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; 10.2 非受控组件非受控组件是表单的代替技术。e.g. \\&lt;input type=”file”> 有时使用受控组件可能很繁琐，因为您要为数据可能发生变化的每一种方式都编写一个事件处理程序，并通过一个组件来管理全部的状态。 非受控组件通过ref属性获取表单值。 1234567891011121314151617181920212223class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" ref=&#123;(input) =&gt; this.input = input&#125; /&gt; //ref属性 &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 10.2.1 默认值在React的生命周期中，表单元素上的value属性将会覆盖DOM中的值。你可以通过defaultValue属性来设置默认值，而不是value。 1234567891011121314render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input defaultValue=\"Bob\" //初始默认是Bob,后续根据用户输入改变 type=\"text\" ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; );&#125; 10.2.2 &lt;input type=&quot;file&quot;&gt;在React中，&lt;input type=&quot;file&quot; /&gt; 始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。 123456789101112131415161718192021222324252627282930313233343536class FileInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; event.preventDefault(); alert( `Selected file - $&#123;this.fileInput.files[0].name&#125;` ); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Upload file: &lt;input type=\"file\" ref=&#123;input =&gt; &#123; this.fileInput = input; &#125;&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render( &lt;FileInput /&gt;, document.getElementById('root')); 11. Refs&amp;DOMRefs 提供了一种方式，用于访问在 render 方法中创建的 DOM 节点或 React 元素。 在典型的 React 数据流中, props是父组件与子组件交互的唯一方式。 某些情况下你需要在典型数据流外强制修改子组件。 使用Refs的情况： 处理焦点、文本选择或媒体控制。 触发强制动画。 集成第三方 DOM 库 如果可以通过声明式实现，则尽量避免使用 refs。 不要使用 refs 来更新组件。 11. 状态提升状态提升：几个组件需要共用状态数据时，可将这部分共享的状态提升到它们最近的父组件中管理。 在React应用中，对应任何可变数据理应只有一个单一“数据源”。 通常，状态都是首先添加在需要渲染数据的组件中。 此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。 你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。 12. 组合 VS 继承React 具有强大的组合模型，我们建议使用组合而不是继承来复用组件之间的代码。 12.1 包含关系对于不能提前知道自己的子组件是什么的组件，建议使用props.children属性将子元素直接传递到输出。 1234567891011121314151617181920function FancyBorder(props) &#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;FancyBorder color=\"blue\"&gt; //&lt;FancyBorder&gt;里的内容都将通过props.children传递给FancyBorder组件。 &lt;h1 className=\"Dialog-title\"&gt; Welcome &lt;/h1&gt; &lt;p className=\"Dialog-message\"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; 13. React理念React应用开发理念： 已有一个JSON接口和原型图。 把UI划分出组件层级并给它们命名。 用react创建一个静态版本。 创建能够复用其他组件的组件，通过props来传递数据。 自顶向下或自底向上构建应用。 简单例子中，自顶向下更容易 大型项目中，自底向上更容易且在构建时有利于编写测试。 完成以上步骤后，你会有一个用于呈现数据模型的可重用组件库（只有render方法）。 定义UI状态的最小表示 最小可变状态要点：不要重复。 根据数据找出state，以下情况不是state： 它是通过 props 从父级传来的 它随着时间推移不变 你能够根据组件中任何其他的 state 或 props 把它计算出来 确定state应该位于哪里 判断步骤： 确定每一个需要这个 state 来渲染的组件。 找到一个公共所有者组件(一个在层级上高于所有其他需要这个 state 的组件的组件) 这个公共所有者组件或另一个层级更高的组件应该拥有这个 state。 如果你没有找到可以拥有这个 state 的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方。 添加反向数据流 事件监听，发生改变时通过setState()改变状态。 参考1. ReactReact是react库的入口，顶级API都在React这个全局变量上。 组件：你可以通过组件，将UI拆分成独立的可重用的模块。每个模块的逻辑也是独立的。 通过React.Component或React.PureComponent来定义组件。 React元素：建议使用JSX来描述UI。每个JSX都是调用React.createElement()的语法糖。 2. React.ComponentReact.Component是类组件的基类。 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 2.1 组件的生命周期每个组件都有几个生命周期方法，可重写这些方法，在过程中的特定时间运行代码。 will前缀的方法：在事情发生之前被调用。 did前缀的方法：在事情发生后被调用。 2.1.1 Mounting装载当组件被创建并插入到DOM时，调用： constructor() componentWillMount() render() componentDidMount() 2.1.2 Updating更新改变props或state时触发更新事件。当重新渲染组件时调用： componentWillReceiveProps(object nextProps)已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)组件判断是否重新渲染时调用 componentWillUpdate(object nextProps, object nextState) render() componentDidUpdate(object prevProps, object prevState) 2.1.3 Unmounting卸载当组件从DOM中删除时，调用： componentWillUnmount()","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://h23.github.io/hexo/tags/React/"}],"keywords":[]},{"title":"函数式编程基础1","slug":"函数式编程基础1","date":"2018-08-12T01:09:50.000Z","updated":"2019-03-15T06:57:05.858Z","comments":true,"path":"2018/08/12/函数式编程基础1/","link":"","permalink":"https://h23.github.io/hexo/2018/08/12/函数式编程基础1/","excerpt":"","text":"函数式编程基础11. 基本概念函数式编程的特性: 函数是一等公民: 函数可作为其他函数的输入输出。回调函数 不可改变量 : 所有的变量只能被赋一次初值。 纯函数: 没有副作用的函数，就是不修改函数外部的变量。 引用透明: 同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。 惰性计算: 一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。 纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数。 2. 范畴论范畴论： 函数式编程的起源是范畴论的数学分支，认为世界上所有概念体系都可以抽象出一个个范畴。 彼此之间存在某种关系概念、事物、对象等等，都构成范畴。任何事物只要找出他们之间的关系，就能定义一个”范畴” 。 箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。 把”范畴”想象成是一个容器，所有的成员是一个集合，变形关系是函数。 范畴论与函数式编程： 范畴论使用函数，表达范畴之间的关系。 函数式编程只是范畴论的运算方法。 在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。 3. 合成与柯里化函数合成： 如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。 12345const compose = function (f, g) &#123; return function (x) &#123; return f(g(x)); &#125;;&#125; 函数的合成还必须满足结合律。 12345compose(f, compose(g, h))// 等同于compose(compose(f, g), h)// 等同于compose(f, g, h) 要合成的函数只能接收一个参数。 柯里化：将多参的函数转化成单参数函数。 123456789101112131415// 柯里化之前function add(x, y) &#123; return x + y;&#125;add(1, 2) // 3// 柯里化之后function addX(y) &#123; return function (x) &#123; return x + y; &#125;;&#125;addX(2)(1) // 3 4. 函子函子： 可用于将一个范畴转成另一个范畴。 它是一种范畴，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。 一般约定，函子的标志就是容器具有map方法。 123456789class Functor &#123; constructor(val) &#123; this.val = val; &#125; map(f) &#123; return new Functor(f(this.val)); &#125;&#125; 函数式编程一般约定，函子有一个of方法，用来生成新的容器。 1234567891011(new Functor(2)).map(function (two) &#123; return two + 2;&#125;);// Functor(4)====&gt;Functor.of(2).map(function (two) &#123; return two + 2;&#125;);// Functor(4) 5. Maybe函子函子接受各种函数，处理容器内部的值。外部函数未必有处理空值的机制，当容器内部的值可能为空，很可能就会出错。Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。 12345678910class Maybe extends Functor &#123; map(f) &#123; return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); &#125;&#125;Maybe.of(null).map(function (s) &#123; return s.toUpperCase();&#125;);// Maybe(null) 6. Either函子条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。 12345678910111213141516class Either extends Functor &#123; constructor(left, right) &#123; this.left = left; this.right = right; &#125; map(f) &#123; return this.right ? Either.of(this.left, f(this.right)) : Either.of(f(this.left), this.right); &#125;&#125;Either.of = function (left, right) &#123; return new Either(left, right);&#125;; 提供默认值 123Either.of(&#123;address: 'xxx'&#125;, currentUser.address).map(updateField); 代替 try…catch 1234567function parseJSON(json) &#123; try &#123; return Either.of(null, JSON.parse(json)); &#125; catch (e: Error) &#123; return Either.of(e, null); &#125;&#125;","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://h23.github.io/hexo/tags/JS/"}],"keywords":[]},{"title":"JS权威指南-函数","slug":"JS权威指南-函数","date":"2018-08-11T01:09:05.000Z","updated":"2019-03-15T06:57:05.754Z","comments":true,"path":"2018/08/11/JS权威指南-函数/","link":"","permalink":"https://h23.github.io/hexo/2018/08/11/JS权威指南-函数/","excerpt":"","text":"1. 基础概念函数组成： 形参：在函数体中像局部变量一样工作。 实参：函数调用时传入。 this：本次调用的上下文。 在JS中，函数即对象。 2. 函数定义定义方式： function关键字 函数名称标识符：若函数定义表达式有name，则该name只存在与函数体中，指代函数对象本身。 （）放形参 { } 放函数体 return，若无则返回undefined 分类： 函数声明 会被预解析 不是真正的语句，只能出现在全局代码或内嵌在其他函数中。不能出现在循环，条件判断或try/cache/finally/with语句中。 函数表达式 1内部函数或私有函数的函数名通常以下划线为前缀。 3. 函数调用调用方式： 作为函数调用 在ES3和非严格的ES5中，this=全局对象 严格模式下，this=undefined 作为方法调用 方法=作为对象属性的函数 this=当前对象 方法链：当方法的返回值是一个对象，这个对象还可以再调用它的方法。 作为构造函数 通过new关键字调用 没有形参的构造函数调用时可省略圆括号 间接调用 通过call(), apply()调用 4. 函数的实参和形参以下几点语法可能存在问题： 函数定义时未指定形参的类型 函数调用时不会对实参做类型检查 函数调用时不会检查参数个数 可能存在的问题： 可选形参 12实参少于形参时，剩下的形参都为undefined。建议在定义函数时，给可选形参设置默认值。 实参对象 123456实参大于形参时，可通过arguments获取未命名值的引用。arguments是一个类数组对象。第一个实参=arguments[0] 。。。callee: 当前正在执行的函数。caller：调用当前正在执行的函数的函数。在严格模式的ES5中，对callee和caller的读写操作都会产生类型错误。 将对象属性用作实参 1形参过多时，不容易记住顺序。可以再定义函数时，将对象作为形参。 实参类型 12当形参为string，但实参是非string时，JS会自动进行类型转换。其他情况下，会出错。建议先做个类型检查。 5. 作为值的函数可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另一个函数等。函数可自定义属性: 12345计数器属性：fun.counter=0;function fun()&#123; return fun.counter++;&#125; 6. 作为命名空间的函数立即调用匿名函数： 123(function foo()&#123; //模块代码 &#125;()) 作用：在此命名空间内定义的变量都不会污染到全局命名空间。 7. 闭包词法作用域：在函数定义时决定，而非调用时决定。分类： 全局作用域 局部作用域 块级作用域-ES6 作用域链： 函数对象可通过作用域链相互关联。 内部作用域可访问外层作用域。 闭包通常是定义在一个函数内部的函数，能够读取外城函数内部变量。闭包内的成员会一直存在内存中。 8. 函数属性，方法和构造函数8.1 属性 length 12arguments.length 实参的个数function.length 形参的个数 prototype 1指向原型对象 8.2 方法 call() apply() 123间接调用函数fun.call(this对象，实参1，实参2。。。)fun.apply(this对象，[实参1，实参2。。。]) bind() 1234不调用函数，仅改变this，也可传实参。返回由指定的this值和初始化参数改造的原函数拷贝。fun.bind(this,实参1，实参2)fun(实参3) toString() 12fun.toString() 返回函数的源码。内置函数返回\"[native code]\" 8.3 构造函数1let fun = new Function(\"形参1\",\"形参2\",....\"函数体\") 注意事项： Function()创建的是匿名函数 可动态创建编译函数 每次调用都会重新编译 函数体代码是在全局作用域下编译执行的 少用 9. 函数式编程 使用函数处理数组：利用map，reduce方法处理数组。 高阶函数：操作函数的函数，接收函数作为参数，并返回一个新函数。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://h23.github.io/hexo/tags/JS/"}],"keywords":[]},{"title":"Webpack4.X","slug":"Webpack4.X","date":"2018-08-03T00:47:22.000Z","updated":"2019-03-15T06:57:05.822Z","comments":true,"path":"2018/08/03/Webpack4.X/","link":"","permalink":"https://h23.github.io/hexo/2018/08/03/Webpack4.X/","excerpt":"","text":"1. Webpack介绍webpack是javascript的静态模块打包器。递归的构建依赖关系图（包含应用程序需要的每个模块 ），然后将所有模块打包成一个或多个bundle。webpack 会把我们项目中使用到的多个代码模块（可以是不同文件类型），打包构建成项目运行仅需要的几个静态文件。可以在打包构建的过程中做很多事情。 webpack作用： 打包（依赖，把多个文件打包成一个JS文件，好处：减少服务器压力、带宽） 转化（eg：less、sass、ts）需要loader 优化（SPA越来越盛行，前端项目复杂度高，webpack可以对项目进行优化） webpack构成： 入口 出口 loader plugins devServer mode webpack安装：webpack webpack-cli mode: 开发环境：平时编写代码的环境 生产环境：项目开发完毕，部署上线 12webpack --mode devlopmentwebpack --mode production 自动压缩文件 2. Webpack基本配置webpack配置文件：webpack.config.js(默认)，webpack配置采用commonJS规范。配置文件整体： 1234567module.exports=&#123; entry:&#123;&#125;, //入口配置* output:&#123;&#125;, //出口配置* modules:&#123;&#125;, //module.rules loader plugins:[], //插件，一般用于生产环境 devServer:&#123;&#125; //开发服务器&#125; 1entry:'src/index.js' //单入口文件 1234567output:&#123; path：__dirname+'/dist' //path必须是绝对路径。__dirname代表当前配置文件所在的绝对路径。是webpack提供的。 filename：'bundle.js' //&#125;path的另一种写法： path:path.resolve(__dirname,'dist') //需要先引入path(const path=require('path')node系统模块自带)，resolve方法可以看成是拼接的作用。 自定义配置文件名称： 1webpack --config 配置文件名称 npm script: 12345script:&#123; 'build':'webpack --config xx.js'&#125;通过npm run build 运行webpack --config xx.js。 3. 多入口、多出多入口： 1entry:['src/index.js','src/index2.js'] //按照顺序依次打包到出口文件。 多出口： 12345678entry:&#123; index:'src/index.js', //多出口需要不同的名称，通过入口文件的属性名传名称 index2:'src/index2.js'&#125;output:&#123; path:path.resolve(__dirname,'dist'), filename：'[name].bundle.js' //[name]代表入口文件的属性名&#125; 4. 服务器、热更新devServer： 下载 webpack-dev-server 使用 123456devServer:&#123; contenBase:path.resolve(__dirname,'dist'), //设置服务器访问的基本目录 host:'localhost', //服务器IP地址 port:'8090', //服务器端口 open:true //自动打开页面&#125; 如果安装某个模块的依赖出错，可删除node_modules，在重新安装。 删除node_modules，通过linux命令rm rf xxx 热更新： 12345678const webpack=require('webpack'); //webpack自带插件devServer:&#123; hot:true //热更新&#125;plugins:[ new wepback.HotModuleReplacementPlugin()] npm script: 1'dev':'webpack-dev-server' 5. loaderloaders: 在webpack里面是一个很重要功能，是加载器、转化器。比如: less/scss 转成css；ES7 8转低版本；jsx转JSloader可有以下几种写法： 1234561. use:['xxx-loader','xxx-loader']2. loader:['xxx-loader','xxx-loader']3. use:[ &#123;loader:'style-loader'&#125;, &#123;loader:'css-loader'&#125; ] 5.1 处理css文件style-loader &amp; css-loader 安装 1cnpm i style-loader css-loader -D 配置 12345678module:&#123; rules:[ &#123; test:/\\.css$/, use:['style-loader','css-loader'] //先由css-loader处理后，在交给style-loader处理 &#125; ]&#125; 5.2 处理图片url-loader &amp; file-loader 安装 1cnpm i file-loader url-loader -D 配置 12345678910&#123; test:/\\.(png|jpg|gif)$/, use:[&#123; loader:'url-loader', options:&#123; limit:50， //当图片大于设置的limit值时，分离出来。 outputPath:'images' //图片打包后的输出路径，在output.path的基础上。 &#125; &#125;]&#125; 5.3 分离CSSextract-text-webpack-plugin 安装 123cnpm i extract-text-webpack-plugin -D webpack3.xcnpm i extract-text-webpack-plugin@next -D webpack4.x 配置 12345678在plugins里面应用: new ExtractTextPlugin(提取出去的路径)在loader里配置： use:ExtractTextPlugin.extract(&#123; fallback:'style-loader', //回滚处理 use:'css-loader', publicPath:'../' //解决css背景图，路径问题。引入图片的路径 &#125;) 5.4 处理less 安装 1cnpm i less less-loader -D 配置 1234&#123; test:/.less$/, use:['style-loader','css-loader','less-loader'] &#125; 分离 1234567&#123; test:/.less$/, use:ExtractTextPlugin.extract(&#123; fallback:'style-loader', use:['css-loader','less-loader'] &#125;)&#125; 5. 处理sass 安装 1cnpm i node-sass sass-loader -D 配置 1234&#123; test:/\\.(sass|scss)$/, use:['style-loader','css-loader','sass-loader']&#125; 分离 1234567&#123; test:/.(sass|scss)$/, use:ExtractTextPlugin.extract(&#123; fallback:'style-loader', use:['css-loader','sass-loader'] &#125;) &#125; 5.6 autoprefixerpostCss 预处理器，专门处理css平台。autoprefixer自动添加前缀。 安装 1cnpm i postcss-loader autoprefixer -D postCss配置 123456准备 postcss.config.js 配置postCss:module.exports =&#123; plugins:[ require('autoprefixer') ]&#125;; loader配置 12345use:[ &#123;loader:'style-loader'&#125;, &#123;loader:'css-loader'&#125;, &#123;loader:'postcss-loader'&#125;] 提取 12345use:ExtractTextPlugin.extract(&#123; fallback:'style-loader', use:['css-loader','postcss-loader'], publicPath:'../' //解决css背景图，路径问题&#125;) 5.7 babelbabel作用： babel用来编译js ESnext转化 jsx 5.7.1 处理ESnextbabel-core bable-loader babel-preset-env 下载 1cnpm i babel-loader babel-core babel-preset-env -D 配置 12345&#123; test:/\\.(js|jsx)$/, use:['babel-loader'], exclude:/node_modules/ //不处理node_modules下的js、jsx&#125; babelrc配置 123456.babelrc配置文件：&#123; \"presets\":[ \"env\" ]&#125; 5.7.2 处理jsx,React 环境 安装 1cnpm i babel-preset-react react react-dom -D 配置 123456.babelrc配置文件：&#123; \"presets\":[ \"env\",\"react\" ]&#125; 6. 插件6.1 html-webpack-plugin自动生成HTML文件：html-webpack-plugin 安装 npm i html-webpack-plugin -D (依赖webpack &amp; webpack-cli，本地需安装) 引入 12webpack.config.js 顶部const HtmlWebpackPlugin = require('html-webpack-plugin') 配置调用 123456789101112131415161718192021222324252627282930313233343536373839plugins:[ new HtmlWebpackPlugin(&#123; template:'src/index.html', //html模板 title：'xxx', //需要在模板中引用&lt;%= htmlWebpackPlugin.options.title%&gt; hash:true //生成链接消除缓存，html自动引入script的src最后加hash minify:&#123; //压缩输出 collapseWhitespace:true //折叠空白区域 &#125; &#125;)]生成多个页面： new HtmlWebpackPlugin(&#123; //new两次 filename:'index.html' //以filename区分开 template:'src/index.html', title：'xxx' &#125; &#125;), new HtmlWebpackPlugin(&#123; filename:'index2.html' template:'src/index.html', title：'xxx' &#125; &#125;)多页面分别引入自己的js： new HtmlWebpackPlugin(&#123; chunks：['入口文件属性名']， //通过chunks filename:'index.html' ， template:'src/index.html', title：'xxx' &#125; &#125;), new HtmlWebpackPlugin(&#123; chunks：['入口文件属性名']， filename:'index2.html' template:'src/index.html', title：'xxx' &#125; &#125;) 6.2 clean-webpack-plugin删除某些东西 安装 引入 调用 1new CleanWebpackPlugin(['dist']) //清除dist目录 6.3 uglifyjs-webpack-plugin打包完以后肯定需要压缩上线: 如何压缩: 1. webpack4.x --mode production 2. 之前版本 uglifyjs-webpack-plugin 123a). cnpm i uglifyjs-webpack-plugin -Db). const uglify = require('xxx);c). new ugliufy() 6.4 purifycss-webpackPurifycss 下载 1cnpm i purifycss-webpack purify-css -D 引入插件 1const PurifyCssWebpack = rewquire('purifycss-webpack'); glob-用于扫描路径 1cnpm i glob -D plugins配置 123new PurifyCssWebpack(&#123; paths:glob.sync(path.join(__dirname, 'src/*.html')) //扫描指定路径中的HTML文件，根据&lt;link&gt;对比查看，删掉没用到的或冗余的css配置。&#125;) 6.5 copy-webpack-plugin将不需要webpack处理的静态资源，原样输出到指定目录下。 下载 1cnpm i copy-webpack-plugin -D 引入 1const CopyWebpackPlugin = require('copy-webpack-plugin'); 配置 123456plugins:[ new CopyWebpackPlugin([&#123; from:path.resolve(__dirname, 'src/assets'), //将此目录下的文件 to:'./public' //输出到此目录 &#125;])] 7. SourceMap上线后调试代码。F12中source里能看到源码。 webpack4.x 开启调试: –mode development webpack3.x之前: 开启sourcemap 1devtool:'source-map', 8. 使用第三库通过ProvidePlugin和 import直接引入区别: import引入之后，无论你在代码中是否使用jquery，打包后，都会打进去，这样其实产生大量的冗余js Provideplugin, 只有你在使用到此库，才会打包 两种方式： import引入 下载 1cnpm i jquery -S 然后引入 1import $ from 'jquery' ProvidePlugin 配置 1234567const webpack = require('webpack');在plugins里面使用:new webpack.ProvidePlugin(&#123; $:'jquery' ....&#125;)","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://h23.github.io/hexo/tags/Webpack/"}],"keywords":[]},{"title":"meta属性","slug":"meta属性","date":"2018-08-03T00:47:04.000Z","updated":"2019-03-15T06:57:05.840Z","comments":true,"path":"2018/08/03/meta属性/","link":"","permalink":"https://h23.github.io/hexo/2018/08/03/meta属性/","excerpt":"","text":"1. 基本概念DPI：测量空间点密度的单位，每英寸能打印上的墨滴数量。PPI：将DPI的概念应用到计算机屏幕上，表示一英寸屏幕上显示的像素点的数量。讨论屏幕时PPI=DPI。屏幕分辨率：屏幕上显示的像素数量（27寸显示器，分辨率为2560*1440px）。 原始分辨率/物理分辨率： 宽度 X PPI * 高度 X PPI。 显示器分辨率：桌面设定的分辨率。若将分辨率减小，显示在PPI相同的屏幕上，系统会自动拉伸所有元素来填补空隙，界面变大。因为不能有半个像素点，使得周围的像素点的颜色只有一部分，变产生了模糊。 视网膜显示屏（Retina）：PPI非常高的设备，人的视网膜无法在屏幕上分辨出像素点。1标准像素=4 Retina像素。物理像素(physical pixel)：显示屏是由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像。物理像素点固定不变（pt），是显示器上的最小物理显示单元。设备独立像素(dip)：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了CSS像素。设备像素比(dpr)： 1个CSS像素占用多少设备像素。在x/y方向上：dpr=pp/dip 。 1px=dpr^2 * 1dp。DP：安卓设备下的设计和显示基本单位。1DP = （PPI/160）PX 。 密度 ldpi mdpi hdpi xhdpi xxhdpi 密度值 120 160 240 320 480 代表分辨率 240*320 320*480 480*800 720*1280 1080*1920 PX 0.75 1 1.5 2 3 PT： 苹果设备下的设计和显示基本单位。1PT = iphone3（163PPI）下 1PX 代表的尺寸。 注意PT还有另一个意思，指印刷行业中的点：1PT=(DPI/72)PX。 SP: 安卓开发用的字体大小单位。当文字尺寸是“正常”时1sp=1dp，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp。 2. viewportviewport指移动设备的屏幕上能用来显示我们的网页的那块区域，但不是浏览器可视区域。一般来讲，移动设备上的viewport都要大于浏览器的可视区域。移动设备上的浏览器会把默认的viewport设置为980px或1024px，这样会造成浏览器出现横向滚动条。css像素 不等于 物理像素。而是根据设备像素和像素比确认的：1px=dpr^2 * 1dp。分辨率越大，css中1px代表的物理像素就会越多。当用户缩放屏幕时也会引起css像素变化。 DPR可通过window.devicePixelRatio 获取。分类： layout viewport：如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过document.documentElement.clientWidth 来获取。 visual viewport：浏览器的可视区域的大小，可以铜通过window.innerWidth来获取。 ideal viewport : 完美适配移动设备的viewport，它的宽度等于移动设备的屏幕宽度。 2.1 &lt;meta&gt;移动设备默认的viewport是layout viewport，可通过meta标签转换成ideal viewport。 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 属性 作用 width 设置layout viewport的宽度，为一个正整数，或字符串”width-device” initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport的高度，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 target-densitydpi（安卓设备私有属性） 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 以下都能实现viewport=ideal viewport： width = device-width: ipad和iphone横屏和竖屏时viewport都是竖屏的ideal viewport。 initial-scale=1 ：IE横屏和竖屏时viewport都是竖屏的ideal viewport。 两种都写就没有问题了。 当两个有冲突时，选最大的值。","categories":[],"tags":[{"name":"META","slug":"META","permalink":"https://h23.github.io/hexo/tags/META/"}],"keywords":[]},{"title":"JS权威指南-对象","slug":"JS权威指南-对象","date":"2018-07-23T08:54:21.000Z","updated":"2019-03-15T06:57:05.760Z","comments":true,"path":"2018/07/23/JS权威指南-对象/","link":"","permalink":"https://h23.github.io/hexo/2018/07/23/JS权威指南-对象/","excerpt":"","text":"1. 基础 2. 创建对象可通过以下几种方式创建对象： 对象直接量 关键字new 构造函数 ES5: Object.create(新对象的原型，xx) Object.create(null) 创建一个没有原型的新对象，该对象不继承任何属性和方法 Object.create(Object.prototype) 创建一个普通的空对象，和{}、new Object()一样 原型概念： 每个JS对象（除NULL）都和另一个对象（即原型）相关联。 通过对象直接量创建的对象都具有同一个原型对象==Object.prototype。 通过new创建的对象原型===构造函数.prototype（new Array()==Array.prototype）。 通过Object.create()创建的对象原型==第一个参数。 Object.prototype没有原型对象。 所有内置构造函数（及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。 3. 属性的查询和设置通过以下方式获取或设置对象的属性值： 点：右侧必须是属性名标识符 方括号：【】内必须是一个计算结果为字符串的表达式 12ES3中，点运算符后的标识符不能是保留字。如果对象的属性名是保留字，必须通过方括号的形式来访问。ES5放宽了此限制。 3.1 作为关联数组的对象关联数组：通过字符串索引而不是数组索引。通过点运算符访问属性时，属性名是一个标识符，程序无法修改。通过方括号访问属性是，属性名用字符串表示，在程序运行时可以修改和创建他们。灵活。 3.2 继承继承：对象的原型属性构成了一个链，通过这条链实现属性的继承。 假设要查询对象O的属性x。 如果O中不存在x，则将在O的原型对象中查询属性x。 如果O的原型对象也没有x，则在原型对象的原型上查找。 直到找到x或查找到一个原型是NULL的对象为止。 只有在查询属性时才会体会到继承的存在，设置属性和继承无关。属性赋值操作先检查原型链，判断是否允许赋值操作。属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性（有特例）。 3.3 属性访问错误查询错误： 查询一个对象和原型链上都不存在的属性==&gt;undefined 查询不存在的对象的属性==&gt;报错 if(obj.xx) obj.xx+=1; obj.xx &amp;&amp; obj.xx+=1; 设置错误： 只读属性 继承属性且只读 不是自有属性 4. 删除属性通过delete运算符删除对象的属性。delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性。在销毁对象的时候，要遍历属性中的属性，依次删除。delete成功或无任何副作用时，返回true。delete返回false的情况： delete不可配的属性 delete全局对象、全局属性 5. 检测属性通过以下方法判断属性是否存在对象中： in： “属性名” in obj==》存在返回true hasOwnProperty(): obj.hasOwnProperty(“属性名”)==》存在且是自有属性返回true propertyIsEnumerable(): obj.propertyIsEnumerable(“属性名”)==》存在且是自有属性且可枚举返回true !== : obj.属性名 !== undefined (当obj存在属性但值为undefined时只能用in) 6. 枚举属性通过以下方式遍历对象的属性： for in，存在的问题：许多实用工具库给Object.prototype添加了新的方法或属性，在ES5之前，这些方法或属性都是可枚举的，都会在for in循环中枚举出来。 通过以下方法过滤上述属性： 1234567for (p in o)&#123; if (!o.hasOwnProperty(p)) continue; //跳过继承的属性&#125;for (p in o)&#123; if (typeof o[p] === \"function\") continue; //跳过方法&#125; ES5： Object.keys()返回对象中可枚举的自有属性的名称的数组。 ES5： Object.getOwnPropertyNames()返回对象中所有自有属性的名称的数组。 7. 属性getter和setter由getter和setter定义的属性称作存取器属性（accessor property），它不同于数据属性，数据属性只有一个简单的值。当程序查询存取器属性的值时，调用getter方法。当程序设置存取器属性的值时，调用setter方法。将赋值表达式右侧的值当作参数传入setter。对象直接量定义存储器属性： 12345var obj=&#123; data_prop:value, //数据属性 get accessor_prop()&#123;&#125;, //存取器属性 set accessor_prop()&#123;&#125;&#125; 8. 属性特性除了包含名字和值之外，属性还包含一些标识它们可写，可枚举，和可配置的特性。 ES5中提供了查询和设置这些属性特性的API，这些API的作用： 给原型对象添加方法，并将它们设置成不可枚举，更像内置方法。 给对象定义不可修改或删除的属性，锁定对象。 数据类型的特性：值，可写性，可枚举性，可配置性。 存取器属性的特性：get, set, 可没举行，可配置性。 ES5中定义了一个属性描述符对象，代表上述特性。通过Object.getOwnPropertyDescriptor()获取。 1Object.getOwnPropertyDescriptor(&#123;x:1&#125;,\"x\") ==&gt;&#123;value:1,writable:true,enumerable:true,configurable:true&#125; 通过Object.defineProperty()设置属性特性： 12345678Object.defineProperty( obj, \"x\", &#123; //不必包含所有特性 value:1, writable:true &#125;) 通过Object.defineProperties()设置多个属性的特性： 1234567891011var p = Object.defineProperties( &#123;&#125;, &#123; x:&#123;value:1,writable:true&#125;, r:&#123; get:function()&#123;&#125;, configurable:true &#125; &#125;) 9. 对象的三个属性9.1 原型属性原型属性在实例对象创建之初就设置好了。 查询对象的原型： ES5： Object.getPrototypeOf(obj) ES3：obj.constructor.prototype 检测一个对象是否是另一个对象的原型： 1p.isPrototypeOf(o) //检测p是否是o的原型 不推荐使用：__proto__属性可直接查询、设置对象的原型。 9.2 类属性类属性是一个字符串，用来表示对象的类型信息。 可通过toString()查询类属性。但很多对象继承的toString()方法重写了，需通过Object.prototype.toString.call(obj).slice(8,-1)查询到类属性。 9.3 可扩展性对象的可扩展性表示是否可以给对象添加新属性。 所有内置对象和自定义对象都是可扩展的，宿主对象的可扩展性是由JS引擎决定的。 ES5提供用来查询和设置对象可扩展性的函数： Object.preventExtensions(obj)： 将对象转换为不可扩展的。一旦转换成不可扩展，就无法转回可扩展的了。 通过Object.isExtensible()判断对象是否是可扩展的。 Object.seal(obj)： preventExtensions基础上，将对象的所有自有属性都设置为不可配置的。 通过Object.isSealed()判断对象是否封闭。 Object.freeze(obj)： seal基础上，将自有的所有数据属性设置为只读。 通过Object.isFrozen()判断对象是否冻结。 10. 序列化对象对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 通过内置函数JSON.stringify() &amp; JSON.parse() 序列化和还原对象。 11. 对象方法 toString() toLocaleString() toJSON() vallueOf()","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://h23.github.io/hexo/tags/JS/"}],"keywords":[]},{"title":"JS权威指南-数组","slug":"JS权威指南-数组","date":"2018-07-23T08:53:53.000Z","updated":"2019-03-15T06:57:05.764Z","comments":true,"path":"2018/07/23/JS权威指南-数组/","link":"","permalink":"https://h23.github.io/hexo/2018/07/23/JS权威指南-数组/","excerpt":"","text":"1. 基础 2. 创建数组通过以下方式创建数组： 数组直接量。数组直接量的语法允许有可选的结尾逗号，故[,,]只有两个元素而非三个。 调用构造函数Array()： new Array() new Array(数组长度) new Array(元素1，元素2。。。) 3. 元素的读写通过[]访问数组的元素。所有的索引都是属性名，但只有0~2^32-2之间的整数属性名才是索引。当使用正确的索引时，数组会自动维护length属性。查询不存在的属性时，不会报错==》undefined 4. 稀疏数组稀疏数组就是包含从0开始的不连续索引的数组。 创建稀疏数组的方式： Array()构造函数指定length 指定数组索引值大于当前length delete操作符 当在数组直接量中省略值时不会创建稀疏数组，省略的元素在数组中是存在的，其值为undefined。 5. 数组长度length属性使数组区别于常规的对象。如果为数组元素赋值，它的索引i大于或等于现有数组长度时，length=i+1.将length设置为小于当前长度的非负整数n时，在数组中索引值大于或等于n的元素将被删除。 6. 添加、删除元素元素添加： 为新索引赋值 push()向数组末尾添加元素 unshift()向数组首部插入元素 元素删除： delete，效果等同于赋值为delete。数组length不变 pop() 删除末尾元素，length-1，返回被删除元素 shift() 删除首部元素，length-1，返回被删除元素 7. 数组遍历遍历数组方式： for循环 for in循环：如果数组同时拥有对象属性和数组属性，返回的属性名很可能是按照创建的顺序而非数值的大小顺序。因此最好不要使用for in遍历数组。 ES5: forEach() 8. 多维数组JS不支持真正的多维数组，但可以用数组的数组来近似。可通过使用两次[]来访问数组的数组中的元素。 9. 数组方法 arr.join()：将数组中所有元素转化为字符串并拼接在一起，返回生成字符串。 arr.reverse()：将数组中的元素颠倒顺序，返回逆序的数组。 arr.sort()：将数组中的元素排序并返回排序后的数组。 不传参数时，以字母表顺序排序。 传入比较函数时：当比较函数返回一个小于0的数字，比较函数的第一个参数在前。 arr.concat(arr2)：拼接数组，返回新数组。 arr.slice(start Index, end Index)：返回指定的数组片段。[start Index,end Index) 可为负数。 arr.splice()：在数组中插入或删除元素的通用方法。 arr.splice(操作起始索引, 要删除的元素个数, 要插入的元素) push()&amp;pop() unshift()&amp;shift() toString()&amp;toLocaleString() 10. ES5中的数组方法 forEach(function(数组元素，元素索引，数组本身){}): 遍历数组，对每个元素执行一次回调函数。 map(function(数组元素，元素索引，数组本身){})：基本同forEach。差别：map的回调函数需要有return，map会返回新数组。 filter(function(数组元素，元素索引，数组本身){}):返回符合条件的新数组。会跳过稀疏数组中缺少的元素。 every(function(数组元素，元素索引，数组本身){})：逻辑判定，所有元素都满足条件返回true。 some(function(数组元素，元素索引，数组本身){})：逻辑判定，有一个元素满足条件返回true。 indexOf() &amp; lastIndexOf() 11. 数组类型检测未知对象是否为数组： ES5: Array.isArray(x) ES3: Object.proptotype.toString.call(x) === “[object Array]”","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://h23.github.io/hexo/tags/JS/"}],"keywords":[]},{"title":"Eslint","slug":"Eslint","date":"2018-07-20T07:33:09.000Z","updated":"2019-03-15T06:57:05.716Z","comments":true,"path":"2018/07/20/Eslint/","link":"","permalink":"https://h23.github.io/hexo/2018/07/20/Eslint/","excerpt":"","text":"1. 简介Eslint目标是提供一个插件化的JS代码检测工具。可组装的JS和JSX检查工具。 通过配置一个json对象检测javascript代码规范。 1.1 安装全局安装：使 ESLint 适用于所有的项目。 123npm install -g eslint //安装eslint --init //设置配置文件eslint yourfile.js //运行ESLint 本地安装：让 ESLint 成为项目构建系统的一部分。 123npm install eslint --save-dev //安装./node_modules/.bin/eslint --init //设置配置文件./node_modules/.bin/eslint yourfile.js //在根目录运行ESLint 2. 配置两种配置ESLint的方式： JS文件中添加注释 - 使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中。 配置文件 - .eslintrc.* , package.json中的eslintConfig字段，或通过命令行指定配置文件eslint -c 配置文件 待检测文件。行内配置 &gt; 命令行 &gt; 配置文件。根目录的.eslintrc文件优先级最高。 运行eslint --init后，会自动创建.eslintrc文件，此文件有默认规则。 123456&#123; \"rules\": &#123; \"semi\": [\"error\", \"always\"], //一条名为semi的规则 \"quotes\": [\"error\", \"double\"] //另一条名为quotes的规则 &#125;&#125; 2.1 解析器选项ESLint默认支持ES5语法，可覆盖配置支持其他版本和JSX。若要支持React需用eslint-plugin-react。 解析器选项使用parserOptions属性配置，可选项： ecmaVersion：设置ECMAScirpt版本。默认3，5，可选值：6,7,8,9,2015,2016,2017,2018。。。 sourceType：可选值“script”，“module” ecmaFeature：额外的语言特性，对象 globalReturn：是否允许在全局作用于下使用return语句 impliedStrict：是否启用全局strict mode（ecmaVersion需是5以上） jsx：是否启用JSX experimentalObjectRestSpread：是否启用实验性的 object rest/spread properties 支持。不建议使用 1234567\"parserOptions\": &#123; \"ecmaVersion\": 6, \"sourceType\": \"module\", \"ecmaFeatures\": &#123; \"jsx\": true &#125; &#125;, 2.2 解析器ESLint默认使用Espree作为解析器。若要设置其他解析器，需满足以下需求： 它必须是本地安装的一个 npm 模块。 它必须有兼容 Esprima 的接口（它必须输出一个 parse() 方法） 它必须产出兼容 Esprima 的 AST 和 token 对象。 以下解析器与ESLint兼容： Esprima Babel-ESLint - 一个对Babel解析器的包装，使其能够与 ESLint 兼容。 typescript-eslint-parser(实验) - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器，这样它就可以在 ESLint 中使用了。这样做的目的是通过 ESLint 来解析 TypeScript 文件（尽管不一定必须通过所有的 ESLint 规则）。 解析器通过parser属性设置： 1\"parser\": \"esprima\" 2.3 环境一个环境定义了一组预定义的全局变量。 环境可通过以下方式设置： 命令行： --env JS文件中设置注释： /* eslint-env node,mocha */ 在配置文件中： 1234\"env\": &#123; \"browser\": true, \"node\": true&#125; 在package.json中： 123456\"eslintConfig\": &#123; \"env\": &#123; \"browser\": true, \"node\": true &#125;&#125; 可用的环境包括（可使用多个）： browser - 浏览器环境中的全局变量。 node - Node.js 全局变量和 Node.js 作用域。 commonjs - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。 shared-node-browser - Node.js 和 Browser 通用全局变量。 es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。 worker - Web Workers 全局变量。 amd - 将 require() 和 define() 定义为像 amd 一样的全局变量。 mocha - 添加所有的 Mocha 测试全局变量。 jasmine - 添加所有的 Jasmine 版本 1.3 和 2.0 的测试全局变量。 jest - Jest 全局变量。 phantomjs - PhantomJS 全局变量。 protractor - Protractor 全局变量。 qunit - QUnit 全局变量。 jquery - jQuery 全局变量。 prototypejs - Prototype.js 全局变量。 shelljs - ShellJS 全局变量。 meteor - Meteor 全局变量。 mongo - MongoDB 全局变量。 applescript - AppleScript 全局变量。 nashorn - Java 8 Nashorn 全局变量。 serviceworker - Service Worker 全局变量。 atomtest - Atom 测试全局变量。 embertest - Ember 测试全局变量。 webextensions - WebExtensions 全局变量。 greasemonkey - GreaseMonkey 全局变量。 2.4 全局变量当访问当前源文件内未定义的变量时，no-undef 规则将发出警告。如果你想在一个源文件里使用全局变量，推荐你在 ESLint 中定义这些全局变量，这样 ESLint 就不会发出警告了。 全局变量可通过以下方式设置： JS文件中设置注释： 1/* global var1:false, var2:false */ //设置了两个全局变量且只读 在配置文件中设置： 123456 \"globals\": &#123; \"var1\": true, //可被重写 \"var2\": false //不可被重写 &#125; 注意：要启用no-global-assign规则来禁止对原生对象或只读的全局变量进行修改。 2.5 插件ESLint 支持使用第三方插件。在使用插件之前，你必须使用 npm 安装它。 全局安装的ESLint只能用全局安装的ESLint插件，本地的也只能用本地的。 通过配置文件设置： 1234\"plugins\": [ \"plugin1\", //插件名称可省略eslint-plugin-前缀 \"eslint-plugin-plugin2\"] 2.6 规则规则有如下等级： &quot;off&quot; 或 0 - 关闭规则 &quot;warn&quot; 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) &quot;error&quot; 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) 可通过如下方式设置规则： 注释： 123/* eslint eqeqeq: \"off\", curly: \"error\" *//* eslint eqeqeq: 0, curly: 2 *//* eslint quotes: [\"error\", \"double\"], curly: 2 */ //若有额外的选项可用数组形式指定，数组的第一项总是规则等级 配置文件 12345\"rules\": &#123; \"eqeqeq\": \"off\", \"curly\": \"error\", \"quotes\": [\"error\", \"double\"]&#125; 配置定义在插件中的一个规则的时候，你必须使用 插件名/规则ID 的形式。比如： 123456789\"plugins\": [ \"plugin1\"],\"rules\": &#123; \"eqeqeq\": \"off\", \"curly\": \"error\", \"quotes\": [\"error\", \"double\"], \"plugin1/rule1\": \"error\" //来自plugin1的rule1规则。插件的名称要删掉eslint-plugin-前缀&#125; 2.6 临时禁止规则可通过注释方式临时禁止规则出现警告： 块注释 12345678/* eslint-disable */ //禁止所有规则alert('foo');/* eslint-enable *//* eslint-disable no-alert, no-console */ //禁止指定的规则alert('foo');console.log('bar');/* eslint-enable no-alert, no-console */ 对整个文件启用或禁用警告 1234/* eslint-disable no-alert */// Disables no-alert for the rest of the filealert('foo'); 行注释 123456789alert('foo'); // eslint-disable-line// eslint-disable-next-linealert('foo');/* eslint-disable-next-line */alert('foo');alert('foo'); /* eslint-disable-line */ 2.7 共享设置共享设置将提供给每一个将被执行的规则。 通过配置文件的settings属性设置： 123\"settings\": &#123; \"sharedData\": \"Hello\"&#125; 3. 规则规则的第一个值是错误级别，可选值： &quot;off&quot; or 0 - 关闭规则 &quot;warn&quot; or 1 - 将规则视为一个警告（不会影响退出码） &quot;error&quot; or 2 - 将规则视为一个错误 (退出码为1) 你可以在配置文件中包含如下一行，开启默认规则（http://eslint.cn/docs/rules/） 1\"extends\": \"eslint:recommended\" 4. JS Standard &amp; ESLint 异同点 差异点 JS Standard ESLint 配置 无需配置 需配置(“extends”: “eslint:recommended”开启默认规则) 自定义 不可修改 可自定义配置 自动格式化工具 有standard –fix 有eslint –fix 临时禁用规则 通过注释同ESLint 通过注释 序号 规则 是否相同 JS Standard ESLint规则及默认情况 1 缩进 否 两个空格 indent，默认4个空格 2 字符串引号 否 单引号(需转义字符除外) quotes(可配单引号，双引号或反勾号) 3 未使用变量 是 禁止 no-unused-vars 4 关键字空格 否 关键字后需加空格 keyword-spacing，默认前后都需有空格 5 函数声明时()与函数名之间是否有空格 是 有 space-before-function-paren，默认有 6 === or == 是 === eqeqeq，=== 7 字符串拼接操作符+之间是否有空格 否 有 space-infix-ops,有，且控制所有操作符 8 逗号前后空格 是 逗号后加空格 comma-spacing，默认前面不能有空格，后面必须加空格 9 else关键字与花括号在同一行 否 是 brace-style是，且控制所有控制语句或声明语句 10 多行IF语句的大括号能否省略 否 不能 11 异常处理中err参数 是 不能遗漏 handle-callback-err 12 全局变量是否要加上window前缀 否 要(document, console and navigator除外) 无 13 连续多行空行 否 不能超过1个空行 no-multiple-empty-lines，默认不能超过2个空行 14 三目运算的操作符位置 否 与后接代码处同一行 operator-linebreak，默认与前面的代码处同一行 15 var能否声明多个变量 否 不能 one-var，默认一个作用域只能有1个var/let/const 16 条件语句中的赋值语句用括号包起来 是 是 no-cond-assign 17 单行代码块{}与内容间是否有空格 是 有 block-spacing 18 变量和函数名统一用驼峰命名法 是 是 camelcase 19 是否允许对象字面量的拖尾逗号 是 不允许 comma-dangle，默认不允许 20 数组/对象字面量和变量声明中逗号的位置 是 行末 comma-style，默认行末 21 访问对象属性时，点号位置 否 与属性同一行 dot-location，默认与对象同一行 22 文件末尾留一空行 是 是 eol-last 23 函数调用时，函数名和开括号之间是否有空格 是 不允许 func-call-spacing 24 键值对中冒号周围的空格 是 键与：不能有空格，：与值必须有个空格 key-spacing 25 构造函数要以大写字母开头 是 是 new-cap 26 无参的构造函数调用时要带上括号 是 是 new-parens 27 getter&amp;setter必须成对存在 是 是 accessor-pairs 28 子类的构造器中一定要调用 super 是 是 constructor-super 29 使用数组字面量而不是构造器 是 是 no-array-constructor 30 避免使用 arguments.callee 和 arguments.caller 是 是 no-caller 31 避免对类名重新赋值 是 是 no-class-assign 32 避免修改使用 const 声明的变量 是 是 no-const-assign 33 避免使用常量作为条件表达式的条件 否 是(循环除外) no-constant-condition，条件和循环语句都不能用常量 34 正则中不要使用控制符 是 是 no-control-regex 35 不要使用 debugger 是 是 no-debugger 36 禁止删除变量 是 是 no-delete-var 37 禁止定义重复参数 是 是 no-dupe-args 38 类中不要定义重复的属性 是 是 no-dupe-class-members 39 对象字面量中不要定义重复的key 是 是 no-dupe-keys 40 switch 语句中不要定义重复的 case 分支 是 是 no-duplicate-case 41 禁止重复模块导入 是 是 no-duplicate-imports 42 正则中不要使用空字符 是 是 no-empty-character-class 43 不要解构空值 是 是 no-empty-pattern 44 不要使用 eval() 是 是 no-eval 45 catch 中不要对错误重新赋值 是 是 no-ex-assign 46 不要扩展原生对象 是 是 no-extend-native 47 避免多余的函数上下文绑定 是 是 no-extra-bind 48 避免不必要的布尔转换 是 是 no-extra-boolean-cast 49 不要使用多余的括号包裹函数 是 是 no-extra-parens 50 禁止case语句落空 是 是 no-fallthrough 51 不要省去小数点前面的0 是 是 no-floating-decimal 52 避免对声明过的函数重新赋值 是 是 no-func-assign 53 禁止对原生对象或只读的全局对象进行赋值 是 是 no-global-assign 54 禁止隐式的 eval() 是 是 no-implied-eval 55 禁止在嵌套的块中出现变量声明或 function 声明 是 是 no-inner-declarations 56 不要向 RegExp 构造器传入非法的正则表达式 是 是 no-invalid-regexp 57 禁止不规则的空白 是 是 no-irregular-whitespace 58 禁止使用 iterator 是 是 no-iterator 59 外部变量不要与对象属性重名 是 是 no-label-var 60 禁止使用标签语句 是 是 no-labels 61 禁止不必要的嵌套代码块 是 是 no-lone-blocks 62 禁止混用空格和制表符作为缩进 是 是 no-mixed-spaces-and-tabs 63 除了缩进，不要使用多个空格 是 是 no-multi-spaces 64 禁止多行字符串 是 是 no-multi-str 65 new 创建对象实例后需要赋值给变量 是 是 no-new 66 禁用function构造器 是 是 no-new-func 67 禁用Object构造器 是 是 no-new-object 68 禁止调用require时使用new操作符 是 是 no-new-require 69 禁止使用 new Symbal 是 是 no-new-symbol 70 禁止对StringNumber和Boolean使用new操作符 是 是 no-new-wrappers 71 禁止将Math、JSON和Reflect对象当作函数进行调用 是 是 “no-obj-calls”: [“error”] 72 禁用八进制字面量 是 是 no-octal 73 禁止在字符串中使用八进制转义序列 是 是 no-octal-escape 74 禁止对 __dirname &amp; __filename 进行字符串连接 是 是 no-path-concat 75 使用 getPrototypeOf 来替代 __proto__ 是 是 no-proto 76 禁止多次声明同一变量 是 是 no-redeclare 77 禁止正则表达式字面量中出现多个空格 是 是 no-regex-spaces 78 return 语句中的赋值必需有括号包裹 是 是 no-return-assign 79 禁止自我赋值 是 是 no-self-assign 80 禁止自身比较 是 是 no-self-compare 81 禁用逗号操作符 是 是 no-sequences 82 禁止覆盖关键字 是 是 no-shadow-restricted-names 83 禁用稀疏数组 是 是 no-sparse-arrays 84 不要使用制表符 是 是 no-tabs 85 禁止在常规字符串中出现模板字面量占位符语法 是 是 no-template-curly-in-string “no-template-curly-in-string”: [“error”] 86 构造函数中使用 this 前请确保 super() 已调用 是 是 no-this-before-super 未配置 87 用 throw 抛错时，抛出 Error 对象而不是字符串 是 是 no-throw-literal “no-throw-literal”: [“error”] 88 行末不留空格 是 是 no-trailing-spaces “no-trailing-spaces”: [“error”] 89 禁止将变量初始化为 undefined 是 是 no-undef-init “no-undef-init”: [“error”] 90 循环语句中需更新循环变量 是 是 no-unmodified-loop-condition “no-unmodified-loop-condition”: [“error”] 91 简化可以简化的三元表达式 是 是 no-unneeded-ternary “no-unneeded-ternary”: [“error”] 92 return，throw，continue 和 break 后不要再跟代码 是 是 no-unreachable “no-unreachable”: [“error”] 93 finally 代码块中不要再改变程序执行流程 是 是 no-unsafe-finally “no-unsafe-finally”: [“error”] 94 关系运算符(in/instanceof)的左值不要做取反操作 是 是 no-unsafe-negation “no-unsafe-negation”: [“error”] 95 避免不必要的 .call() 和 .apply() 是 是 no-useless-call “no-useless-call”: [“error”] 96 避免使用不必要的计算值作对象属性 是 是 no-useless-computed-key “no-useless-computed-key”: [“error”] 97 禁止多余的构造器 是 是 no-useless-constructor 未配置 98 禁用不必要的转义 是 是 no-useless-escape “no-useless-escape”: [“error”] 99 禁止在import和export和解构赋值时将引用重命名为相同的名字 是 是 no-useless-rename “no-useless-rename”: [“error”] 100 同行中禁止对象和属性间有空白 是 是 no-whitespace-before-property “no-whitespace-before-property”: [“error”] 101 禁用with语句 是 是 no-with “no-with”: [“error”] 102 强制将对象的属性放在不同的行上 是 是 object-property-newline 未配置 103 代码块中避免多余空行 否 是 padded-blocks，默认需要空行 未配置 104 展开运算符和表达式之间不能有空格 是 是 rest-spread-spacing “rest-spread-spacing”: [“error”, “never”] 105 分号后面需加上一个空格 是 是 semi-spacing “semi-spacing”: [“error”] 106 代码块{}前后需有个空格 是 是 space-before-blocks 未配置 107 圆括号与内容间不能有空格 是 是 space-in-parens “space-in-parens”: [“error”] 108 一元运算符后面跟一个空格 是 是 space-unary-ops “space-unary-ops”: [“error”] 109 注释首尾留空格 是 是 spaced-comment “spaced-comment”: [“error”] 110 模板字符串中变量前后不加空格 是 是 template-curly-spacing “template-curly-spacing”: [“error”] 111 要求使用 isNaN() 检查 NaN 是 是 use-isnan “use-isnan”: [“error”] 112 typeof只能和已有的数据类型作比较 是 是 valid-typeof “valid-typeof”: [“error”] 113 要求 IIFE 使用括号括起来 是 是 wrap-iife 未配置 114 yield * 中的 * 前后的空格 否 *前后都要有空格 yield-star-spacing，默认前面没有，后面有 “yield-star-spacing”: [“error”] 115 禁止yoda条件 是 是 yoda 未配置 116 句尾是否使用分号 否 不要使用 semi，默认都要使用 semi: [“error”, “always”] 117 不要使用 (, [, or ` 等作为一行的开始 否 是 no-unexpected-multiline，上一行有分号结尾就可以 “no-unexpected-multiline”: [“error”]","categories":[],"tags":[{"name":"Eslint","slug":"Eslint","permalink":"https://h23.github.io/hexo/tags/Eslint/"}],"keywords":[]},{"title":"npm","slug":"npm","date":"2018-06-27T07:33:09.000Z","updated":"2019-03-15T06:57:05.845Z","comments":true,"path":"2018/06/27/npm/","link":"","permalink":"https://h23.github.io/hexo/2018/06/27/npm/","excerpt":"","text":"npm简介npm是软件注册表，包含超过600000个包（即，代码模块）。包的结构使您可以轻松跟踪依赖项和版本。 npm组成： 网站：开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径 。 注册表：巨大的数据库，保存了每个包（package）的信息。将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 命令行工具：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。 安装在安装 Node 的时候，会连带一起安装 npm。 基础命令： npm install npm -g 更新到最新版本 npm help 查看 npm 命令列表 npm -l 查看各个命令的简单用法 npm -v 查看 npm 的版本 npm config list -l 查看 npm 的配置 注册npm账号npm adduser 根据提示输入用户名，密码和邮箱。注册完要验证邮箱。 123常见错误：npm ERR! Unable to authenticate, need: Basic解决：用户名被注册过了，换一个就好了。 上传包 上传包之前需先登录账号。 npm login登录 npm whoami 查看当前登录的账号。 在目标文件夹下初始化。 npm init 根据提示输入相应信息。注意包名必须是唯一的。 完成后会生成package.json文件。 编写待上传的代码模块。 创建readme.md简单说明下包的作用以及用法。 发布 npm publish 123常见错误：You do not have permission to publish 'somepackage'.Are you logged in as the corrent user? 解决：包名重复了，修改package.json中的name 。 1可以通过npm unpublish撤销发布，要等24小时候才能重新发布。 发布成功后可在官网上找到刚发布的包。可通过npm install 包名安装测试。 更新包后重新上传 更新版本号 npm version xx 重新发布 npm publish","categories":[],"tags":[{"name":"NPM","slug":"NPM","permalink":"https://h23.github.io/hexo/tags/NPM/"}],"keywords":[]},{"title":"ES6+Babel","slug":"ES6-Babel","date":"2018-06-27T07:05:02.000Z","updated":"2019-03-15T06:57:05.710Z","comments":true,"path":"2018/06/27/ES6-Babel/","link":"","permalink":"https://h23.github.io/hexo/2018/06/27/ES6-Babel/","excerpt":"","text":"1. 历史ECMAScript和JavaScript ECMA是标准，JS是实现 ECMAScript简称ECMA或ES 目前版本 低级浏览器主要支持ES 3.1 高级浏览器正在从ES 5过渡到ES 6 2. 兼容性http://kangax.github.io/compat-table/es5/http://kangax.github.io/compat-table/es6/ ES6(ES2015)支持的浏览器：IE10+、Chrome、FireFox、移动端、NodeJS 3. BabelBabel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 3.1 编译操作步骤： 在项目文件夹下初始化package.json 12npm initnpm init -y 安装babel-cli 和 es2015预设 12npm install babel-cli --save-devnpm install babel-preset-es2015 --save-dev //es2015:转换成es5用到的插件集合 配置package.json，添加scripts 123\"scripts\": &#123; \"build\": \"babel src -d lib\" //配置编译路径：src为原ES6目录，lib为编译后的ES5目录 &#125; 在根目录下创建.babelrc文件，配置presets 1234创建的文件名为.babelrc.&#123; \"presets\" : [\"es2015\"]&#125; 在src目录下创建JS文件，编写ES6代码 编译ES6代码 1npm run build 编译好的代码在lib目录下。 3.2 预设预设是一些插件的集合。预设可分成两类：按年份，按阶段。 按年份: 已经批准的，浏览器将要实现的功能 e.g. babel-preset-es2015 按阶段：没有被批准的功能 每个提案有5个阶段 ： stage-0 稻草人阶段， 就是一个想法 stage-1 建议阶段，值得去努力 stage-2 草案阶段， 初始的细节描述 stage-3 候选阶段，草案基本完成，浏览器厂商实验性的实现 stage-4 完成阶段，添加到下一年的版本中 前期阶段的插件大于后期阶段的插件 ，stage 0&gt;stage 1&gt;stage 2&gt;stage 3 ，只安装一个就行 。 如果没提供es2015相关的预设，阶段性的预设就不能用。 3.3 babel-polyfillBabel默认只转换新的JS语法，而不转换新API。若想要使用新API，就必须使用babel-polyfill。 原理：将API用JS重写出来，那么旧浏览器就可以使用这个API了。 操作步骤： 安装： npm install babel-polyfill --save--dev 安装完成后，node_modules/babel-polyfill/dist下面有polyfill.min.js 引入polyfill.min.js文件，即可使用新API 4. ES64.1 变量声明4.1.1 原来的var的问题 可以重复声明，后面的覆盖前面定义的。 无法限制修改。 没有块级作用域。 4.1.2 let 不能重复声明 变量 可修改 块级作用域变量 {}内的代码块 不存在变量提升 4.1.2 const 不能重复声明 常量 不可修改，修改会报错 块级作用域变量 不存在变量提升 注意：如果const一个对象，对象所包含的值是可以被修改的。只要对象所指向的地址没变就行。 4.2 解构赋值解构允许使用模式匹配的方式进行绑定，并支持匹配数组和对象（或其他具备iterator接口的数据结构）。 本质：利用数组/对象（或其他具备iterator接口的数据结构），批量定义并初始化变量。 1.针对具备iterator接口的数据结构。2.左右两边结构必须一样。3.声明和赋值不能分开(必须在一句话里完成)。 123456789数组：按次序赋值let [a,b,c]=[12,5,8];console.log(a,b,c); ==&gt;a=12,b=5,c=8let [x, [y,z]] = [1, [2.1, 2.2]]; //嵌套赋值console.log(x,y,z); ==&gt;x=1,y=2.1,z=undefinedlet [, , x] = [1, 2, 3]; //省略赋值console.log(x); ==&gt;x=3 1234567对象：无序，按key赋值let &#123;c,a,b&#125;=&#123;a: 12, b: 5, c: 8&#125;;console.log(a,b,c); ==&gt;a=12,b=5,c=8let &#123;name: myname, age: myage&#125; = &#123;name:'zfpx',age:8&#125;;console.log(name,age,myname,myage); ==&gt;name,age报错，myname=zfpx, myage=18先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 4.3 默认值在赋值或传参的时候可以使用默认值。 ES6 内部使用严格相等运算符（===），判断一个位置是否有值， 所以只有一个数组成员严格等于undefined，默认值才会生效。 123456789101112赋值：let [a = \"a\", b = \"b\", c =new Error('C必须指定')] = [1, , 3];console.log(a, b, c); ==&gt;a=1, b=\"b\", c=3传参：function ajax (&#123;method = \"get\", data&#125;) &#123; console.log(arguments); ==&gt;&#123;method: \"post\",data: &#123;\"name\": \"zfpx\"&#125;&#125;&#125;ajax(&#123; method: \"post\", data: &#123;\"name\": \"zfpx\"&#125;&#125;); 4.4 扩展操作符把…放在数组前面可以把一个数组进行展开。 4.4.1 展开数组1let arr=[1,2,3]; ==&gt;...arr =1,2,3 4.2.2 替代concat12345var arr1 = [1, 3];var arr2 = [3, 5];var arr3 = arr1.concat(arr2);var arr4 = [...arr1, ...arr2];console.log(arr3,arr4); ==&gt; arr3===arr4 4.4.3 不定参数Rest1234function show(a, b, ...args)&#123;&#125;show(1,2,43,5,2) ==&gt;...args=43,5,2Rest Parameter必须是最后一个 4.5 字符串4.5.1 新方法 1.includes()：判断是否包含字符串，包含则返回true 1234const str = 'hahay'console.log(str.includes('y')) // true可接受第二个参数，表示开始搜索的位置 2.repeat(): 获取字符串重复n次，将原字符串重复n次 12const str = 'he'console.log(str.repeat(3)) // 'hehehe' 3.startsWith() 和 endsWith(): 判断是否以给定文本开始或者结束 123456const str = 'hello world!'console.log(str.startsWith('hello')) // trueconsole.log(str.endsWith('!')) // truestartsWith可接受第二个参数，表示开始搜索的位置endsWith可接受第二个参数，表示从开始到第n个字符，是否以xx结束 4.5.2 模板字符串模板字符串：用反引号包含，其中的变量用${}括起来。 作用： 字符串连接，将表达式嵌入字符串中进行拼接。 12const name = 'lux'console.log(`hello $&#123;name&#125;`) ==&gt;hello lux 折行：所有模板字符串的空格和换行，都是被保留的 123const template = `&lt;div&gt; &lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;` 4.6 函数4.6.1 箭头函数箭头函数简化了函数的的定义方式，一般以 “=&gt;” 操作符左边为输入的参数，而右边则是进行的操作以及返回的值inputs=&gt;output 。 1234567891011函数var foo=function 名字()&#123;&#125;箭头函数let foo=()=&gt;&#123;&#125;1. 如果只有一个参数，()可以省2. 如果只有一个return，&#123;&#125;可以省let foo=a=&gt;a+1;foo(2); //3 特点： 不需要 function 关键字来创建函数 箭头函数可以替换函数表达式，但是不能替换函数声明 箭头函数与包裹它的代码共享相同的this对象. 如果箭头函数在其他函数的内部，它也将共享该函数的arguments变量。 4.6.2 函数名字ES6给函数添加了一个name属性 。 12var desc = function descname()&#123;&#125;console.log(desc.name); ==&gt;descname 4.7 数组：4.7.1 Array.from()将一个数组或者类数组变成数组,并返回该数组。 1let newArr = Array.from(document.querySelectorAll(\"*\")); 4.7.2 Array.of()功能与new Array()类似。单个参数时有差别: 12let a=new Array(5); ==&gt;a=[,,,,]let b=Array.of(5); ==&gt;b=[5] 4.7.3 find()返回第一个符合条件的数组元素。无则返回undefined 1arr.find((value,index,array)=&gt;条件); 4.7.4 findIndex()返回第一个符合条件的数组元素的索引。无则返回-1 123arr.find((value,index,array)=&gt;条件);[1, 5, 10, 15].find(a=&gt;a&gt;9) // 2 4.7.5 map()对数组的每个元素执行一次回调函数。返回处理结果。映射 一个对一个 12345var result = arr.map(function(item)&#123; //item即数组元素 return item*2;&#125;)let result = arr.map(item=&gt;item*2); 4.7.6 reduce()汇总 一堆出来一个 算个总数，平均数 12345678910111213141516总数计算：let result=arr.reduce(function (tmp, item, index)&#123; //tmp 中间值 //item 数组元素 //index 数组元素索引 return tmp+item;&#125;);平均数计算：let result=arr.reduce(function (tmp, item, index)&#123; if(index!=arr.length-1)&#123; //不是最后一次 return tmp+item; &#125;else&#123; //最后一次 return (tmp+item)/arr.length; &#125;&#125;); 4.7.7 filter()通过回调函数的返回值判断是否留下数组元素值。ture-&gt;留下 12345678留下可被3整除的数：let result=arr.filter(item=&gt;&#123; if(item%3==0)&#123; return true; &#125;else&#123; return false; &#125;&#125;); 4.7.8 forEach()循环(迭代) 12345arr.forEach((item,index)=&gt;&#123; //item 数组元素 //index 数组元素索引 alert(index+': '+item);&#125;); 4.7.9 fill()arr.fill(newItem,startIndex,endIndex) 将[startIndex,endIndex)之间的数组元素用newItem代替。 1[0, 0, 0].fill(7, 1, 2); // =&gt; [0,7,7] 4.8 SymbolSymbol是ES6中的一种新的原始数据类型，表示独一无二的值 。 不能使用new，会报错。 1234567891011121314151617let s = Symbol();typeof s // \"symbol\"可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)相同参数的Symbol函数的返回值是不相等的。let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false注意：Symbol 值不能与其他类型的值进行运算，会报错。Symbol 值可以显式转为字符串。Symbol 值也可以转为布尔值，但是不能转为数值。 4.8.1 作为属性名的SymbolSymbol 值作为对象属性名时，不能用点运算符。 12345678910let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;; 4.9 集合4.9.1 Set一个Set是一堆东西的集合,Set有点像数组,不过跟数组不一样的是，Set里面不能有重复的内容。key和value一样。 1234561. Set() 构造函数，用来生成Set数据结构。const s =new Set();2. Set()可接受一个数组（或具有iterable接口的其他数据结构）作为参数，初始化。const set = new Set([1,2,3,4]);const set = new Set(document.querySelectorAll('div')); 4.9.1.1 set方法 操作方法 set.add(value)： 添加set元素，并返回set结构本身。重复值不会被添加。 内部用===判断两值是否相同（差别NaN等于自身）。 s.add(1).add(2).add(2);返回本身则可链式操作 set.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 s.delete(2); set.has(value)：返回一个布尔值，表示该值是否为Set的成员。 s.has(1) ==&gt;true s.has(2) ==&gt;false set.clear()：清除所有成员，没有返回值。 遍历方法：遍历顺序就是插入顺序。 set.keys()：返回键名的遍历器，行为与values()一致 set.values()：返回键值的遍历器，行为与keys()一致 set.entries()：返回键值对的遍历器 set.forEach()：使用回调函数遍历每个成员 set实例默认可遍历，默认遍历器生成函数就是values()。 Set.prototype[Symbol.iterator] === Set.prototype.values 123456789101112131415161718192021let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()/set.values()/set) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"]set = new Set([1, 4, 9]);set.forEach((value, key，set) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 4.9.1.2 set属性12Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。 4.9.1.3 其他Array.from()可以将 Set 结构转为数组。 12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 去除数组重复成员 : 123456function dedupe(array) &#123; return Array.from(new Set(array)); //方法1 return [...new Set(array)]; //方法2&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 交集，并集和差集 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 4.9.2 MapObject本质上是键值对的集合（“字符串-值”的对应），键只能是字符串。 Map也是键值对的集合（“值-值”的对应），键可以是任意类型。 key用===对比，但NaN等于NaN。若key是对象，则比较的是内存地址。key的排列顺序是按添加顺序进行排列的。 构造函数： 12345const m = new Map();const map = new Map([ ['name', '张三'], ['title', 'Author']]); 4.9.2.1 map方法&amp;属性123456789101112131415操作方法：1. map.set(key,value) 添加map成员，返回map本身，可链式操作。2. map.get(key) 有则返回value，无则返回undefined。3. map.has(key)4. map.delete(key)5. map.clear()遍历方法：6. map.keys()7. map.values()8. map.entries()9. map.forEach(function(key,value,map)&#123;&#125;)属性：10. map.size 4.10 对象的扩展4.10.1 对象初始化简写1234567891011121314151.键值对重名时，可简写成如下：function people(name, age) &#123; return &#123; name, ==&gt;name:name age ==&gt;age:age &#125;;&#125;2.添加方法，可简写成如下：const people = &#123; name: 'lux', getName () &#123; ==&gt;getName:function()&#123;...&#125; console.log(this.name) &#125;&#125; 4.10.2 Object.assign()把多个对象的属性复制到一个对象中。第一个参数是复制的对象,从第二个参数开始往后,都是复制的源对象。浅复制 1234567const objA = &#123; name: 'cc', age: 18 &#125;const objB = &#123; address: 'beijing' &#125;const objC = &#123;&#125; // 这个为目标对象const obj = Object.assign(objC, objA, objB)console.log(objC) // &#123; name: 'cc', age: 18, address: 'beijing' &#125;console.log(obj) // &#123; name: 'cc', age: 18, address: 'beijing' &#125; 4.10.3 Object.is()对比两个值是否相等。与===类似，差别：一是+0不等于-0，二是NaN等于自身。 12345console.log(Object.is(NaN,NaN)); //trueconsole.log(Object.is(-0,0)); //falseconsole.log(NaN===NaN); //falseconsole.log(-0===0); //true 4.11 Classes类只是一个语法糖，通过class关键字让语法更接近传统的面向对象模式，本质上还是基于原型的。 构造函数类ES5写法: 123456789function User(name,pass)&#123; this.name=name; this.pass=pass;&#125;User.prototype.showName=function()&#123; alert(this.name);&#125;var a=new User(\"h23\",12434);a.showName(); ES6写法: 12345678910class User&#123; construtor(name,pass)&#123; this.name=name; this.pass=pass &#125; showName()&#123; alert(this.name); &#125;&#125; 4.11.1 继承ES5写法： 12345678910function VipUser(name, pass, level)&#123; User.call(this, name, pass); //属性继承 this.level=level;&#125;VipUser.prototype=new User(); //方法继承VipUser.prototype.constructor=VipUser; //重新指定constructorVipUser.prototype.showLevel=function ()&#123; alert(this.level);&#125;; ES6写法： 123456789class VipUser extends User&#123; //extends已实现方法的继承 construtor(name,pass,level)&#123; super(name,pass); //属性继承 this.level=level; &#125; showLevel()&#123; alert(this.level); &#125;&#125; 4.11.2 get与setgetter可用来获取属性，setter可用来设置属性。 123456789101112131415class Person &#123; constructor()&#123; this.hobbies = []; &#125; set hobby(hobby)&#123; this.hobbies.push(hobby); &#125; get hobby()&#123; return this.hobbies; &#125;&#125;let person = new Person();person.hobby = 'basketball';person.hobby = 'football';console.log(person.hobby); //[\"basketball\", \"football\"] 4.11.3 静态方法静态方法：不需要实例化类就能使用的方法。 123456class Person &#123; static add(a,b)&#123; return a+b; &#125;&#125;console.log(Person.add(1,2)); 4.11.4 super关键字super指向当前对象的原型对象。只能用在对象的方法之中，用在其他地方都会报错。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。 4.11.5 Object.setPrototypeOf()设置一个对象的prototype对象，返回参数对象本身。 1234567891011121314// 格式Object.setPrototypeOf(object, prototype)// 例子let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 4.11.6 Object.getPrototypeOf()读取一个对象的原型对象。 1Object.getPrototypeOf(obj); 4.12 Iterator迭代器数据集合：数组，对象，Map，Set。 Iterator：是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。这种遍历操作是依次处理该数据结构的所有成员。 作用： 为各种数据结构提供一个统一的，简便的访问接口。 使得数据结构的成员能按某种次序排列。 用于for…of循环（for…in 遍历每一个属性名称,而 for…of遍历每一个属性值 ） 具备iterator接口的数据结构可进行以下操作： 解构赋值 扩展运算符 for of循环 4.12.1 部署接口4.12.1.1 原生接口有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。 凡是具有 Symbol.iterator 属性的数据结构都具有 Iterator 接口。 123const arr = [1, 2, 3];const itArr = arr[Symbol.iterator]();itArr.next(); 4.12.1.2 接口函数1234567891011121314151617181920const arr = [1, 2, 3];function iterator(arr)&#123; let index = 0; //创建一个指针对象，指向起始位置。 return &#123; next: function ()&#123; //每次调用next方法，则将指针指向下一个数据结构成员。直到指向数据结构的结束位置。 return index &lt; arr.length ? &#123;value: arr[index++], done: false&#125; : &#123;value: undefined, done: true&#125;; //value是当前成员的值，done是布尔值表示遍历是否结束。 &#125; &#125;&#125;const it = iterator(arr);console.log(it.next()); ==&gt;value=1,done=falseconsole.log(it.next()); ==&gt;value=2,done=falseconsole.log(it.next()); ==&gt;value=3,done=falseconsole.log(it.next()); ==&gt;value=undefined,done=true 4.12.1.3 对象接口给一个对象部署iterator接口，其实就是对该对象做一种线性转换。 12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 4.12.2 for…offor...of允许你遍历可迭代的数据结构，比如数组、字符串、映射、集合等，for...of可以替代另外两种循环语句for...in和forEach()。 12345for (variable of iterable) &#123; statement &#125;//variable：每个迭代的属性值//iterable：一个具有可枚举属性并且可以迭代的对象 12345678遍历数组：const iterable=[\"mini\",\"max\",\"middle\"];for(const value of iterable)&#123; console.log(value);&#125;==&gt;mini==&gt;max==&gt;middle 1234567遍历Map:const iterable = new Map([['one', 1], ['two', 2]]); for (const [key, value] of iterable) &#123; console.log(`Key: $&#123;key&#125; and Value: $&#123;value&#125;`); &#125; ==&gt; Key: one and Value: 1 ==&gt; Key: two and Value: 2 4.13 生成器(Generator)Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 解释： Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 Generator 函数与普通函数的差别： function关键字与函数名之间有个星号。 函数内部使用yield表达式，定义不同的内部状态。 调用generator函数后，并不执行，而是返回一个指向内部状态的指针对象（即遍历器对象）。 调用遍历器对象的next()，使得指针移向下一个状态（下一个yield或return结束）。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 12345678910function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next() ==&gt;&#123; value: 'hello', done: false &#125;hw.next() ==&gt;&#123; value: 'world', done: false &#125;hw.next() ==&gt;&#123; value: 'ending', done: true &#125;hw.next() ==&gt;&#123; value: undefined, done: true &#125; 4.13.1 yield表达式遍历器对象的next方法的运行逻辑： 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。 yield表达式如果用在另一个表达式之中，必须放在圆括号里面。 yield表达式 用作函数参数 或放在赋值表达式的右边，可以不加括号。 4.13.2 next方法的参数next方法的参数表示上一个yield表达式的返回值。 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://h23.github.io/hexo/tags/ES6/"}],"keywords":[]},{"title":"JavaScript权威指南-1","slug":"JavaScript权威指南-1","date":"2018-06-25T00:57:38.000Z","updated":"2019-03-15T06:57:05.769Z","comments":true,"path":"2018/06/25/JavaScript权威指南-1/","link":"","permalink":"https://h23.github.io/hexo/2018/06/25/JavaScript权威指南-1/","excerpt":"","text":"第二章 词法结构编程语言的词法结构：用来描述如何使用这门语言来编写程序。 如规定： 变量名是什么样的 怎么写注释 程序语句之间如何分隔等 1.字符集JavaScript程序是用Unicode字符集编写的。Unicode是ASCII和Latin-1的超集。 1.1 区分大小写关键字，变量，函数名等所有标识符都必须采用一致的大小写形式。 1.2 Unicode转义序列有些计算机硬件和软件无法显示或输入Unicode字符全集。为了兼容，JavaScript定义了一种特殊序列–Unicode转义序列。 用6个ASCII字符（\\u开头，后接4个十六进制数）表示任意16位Unicode内码。 2.注释12345//单行注释/**多行注释*/ 3.直接量直接量程序中直接使用的数据值。 4.标识符标识符用来对变量和函数进行命名。 规则： 只能包含数字，字母，下划线和美元符。 不能以数字开头。 5.保留字关键字：javascript把一些标识符拿出做自己的关键字。这些关键字不能再作为变量名，函数名。 6.可选的分号javascript使用分号将语句分隔开。 如果语句各自独占一行，可省略分号。 程序结尾或花括号之前的分号也可省略。 return，break，continue后若紧跟着换行，javascript会在换行处填补分号。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://h23.github.io/hexo/tags/JS/"}],"keywords":[]},{"title":"Hexo学习","slug":"Hexo笔记","date":"2018-06-20T08:20:47.000Z","updated":"2019-03-15T06:57:05.729Z","comments":true,"path":"2018/06/20/Hexo笔记/","link":"","permalink":"https://h23.github.io/hexo/2018/06/20/Hexo笔记/","excerpt":"","text":"Hexo结合GitHub搭建博客基础Hexo简介Hexo是一个博客框架，用Markdown解析文档，用主题生成静态网页。 Hexo安装前提条件：已安装nodeJS，git安装： npm install -g hexo-cli 博客搭建步骤 建站 新建文章 开启服务器，本地测试 生成文件 部署到GitHub 建站在指定文件夹下 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 完成命令后，folder下多出如下文件：_config.yml: 网站的配置信息。source: 存放用户资源的地方themes: 主题文件夹package.json: 应用程序的信息scaffolds: 模版文件夹 新建文章hexo new [layout] &lt;title&gt; layout默认为post，存放路径source/_posts使用markdown语法，编辑新建的文章 开启服务器，本地测试安装服务器： npm install hexo-server –save开启服务器： hexo server开启后，可通过http://localhost:4000访问博客。 生成文件hexo generate 生成的文件，存放在public中 部署到GitHub安装hexo-deployer-git npm install hexo-deployer-git --save 方式1：修改_config.yml配置文件，在Deployment部分中： deploy: type: git repo: &lt;GitHub Pages仓库 url&gt; 完成后，可通过xx.github.io来访问博客。这种方式，会直接覆盖仓库。原内容需要放到public下重新提交。 方式2：1.新建一个仓库，用于存放hexo博客。2.修改_config.yml配置文件，在URL部分中： url: https://xx.github.io/blog root: /blog/ 3.在Deployment部分中： deploy: type: git repo: 新仓库地址 4.在GitHub上，修改新仓库的GitHub Pages为master branch完成后，可通过xx.github.io/blog来访问博客。 更换主题(可选)1.在Hexo主题上，找到相应主题。2.将主题clone到themes目录下3.修改_config.yml配置文件，在Extensions部分中： theme: 主题名 在多台电脑上更新博客公司电脑上配置： 在GitHub上新建分支 将新建的分支设为默认分支 Settings-&gt;Branches-&gt;Default branch 将该仓库克隆到本地 执行git branch，当前分支应为新建的分支。 将Hexo的部署文件全部复制进克隆的仓库下。 将克隆仓库的文件全部提交到新建分支上。 123git add.git commit -m \"description\"git push 1将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 提交成功后，可在github上查看两个分支的差异。 在家的电脑上配置： 克隆仓库 执行npm install 更新博客 执行hexo d -g，此改动更新到master上 提交到github，此改动更新到hexo上","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://h23.github.io/hexo/tags/Hexo/"}],"keywords":[]},{"title":"Markdown学习笔记","slug":"Markdown笔记","date":"2018-06-20T06:24:50.000Z","updated":"2019-03-15T06:57:05.775Z","comments":true,"path":"2018/06/20/Markdown笔记/","link":"","permalink":"https://h23.github.io/hexo/2018/06/20/Markdown笔记/","excerpt":"","text":"Markdown语法学习学习内容 标题 区块引用 列表 代码区块 分割线 图片 链接 图片 自动链接 标题123用#符号标识。写法： # 标题名称#可用1-6个，对应1-6级标题 例子：## 我是二级标题 我是二级标题 区块引用123在引用的每行前加上&gt;区块引用可嵌套Markdown语法在区块引用中有效 例子：&gt;我是 &gt;区块 &gt;引用 我是区块引用 列表12有序列表：数字接着一个英文句点无序列表：列表项目前加上星号，加号或减号 例子：1. 我是有序列表；* 我是无序列表 我是有序列表 我是无序列表 代码12代码块：代码每行缩进 4 个空格或是 1 个制表符行内代码：将代码用```包裹 例子 我是代码块 1我是行内代码 分割线1在一行中用三个以上的星号、减号、底线来建立一个分隔线 例子：*** 图片123456方式1：直接使用&lt;img&gt;方式2：行内式 ![Alt text](url \"Title\")方式3：参考式 ![Alt text][id] 然后在文档任意处 [id]: url \"Optional title\"方式2/3无法设置图片大小id不区分大小写 例子： ![云图片]（http://img.hb.aicdn.com/af774558816fffd199779f0a94a24e1a107b16b1142b1-VYaXfq_fw658 “云图片”） 链接123456方式1：直接使用&lt;a&gt;方式2：行内式 [显示文字](url \"Title\")方式3：参考式 [显示文字] [id] 然后在文档任意处 [id]: url \"Optional Title\"id不区分大小写若省略id则 id=显示文字 例子：[百度]（http://www.baidu.com “百度首页”） 百度 强调12等同于&lt;em&gt;:用一个*或_包裹等同于&lt;strong&gt;：用两个*或_包裹 例子：我是em 我是strong 自动链接1将链接URL用&lt;&gt;包裹，Markdown会转为&lt;a&gt;，且内容为URL 例子：&lt;http://example.com/&gt;http://example.com/","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://h23.github.io/hexo/tags/Markdown/"}],"keywords":[]}]}